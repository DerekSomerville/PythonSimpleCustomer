from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import with_metaclass, viewkeys

import types

from . import _inputstream
from . import _tokenizer

from . import treebuilders
from .treebuilders.base import Marker

from . import _utils
from .constants import (
    space_characters, ascii_upper2_lower,
    special_elements, heading_elements, cdata_elements, rcdata_elements,
    token_types, tag_token_types,
    namespaces,
    html_integration_point_elements, mathml_text_integration_point_elements,
    adjust_foreign_attributes as adjust_foreign_attributes_map,
    adjust_math_ml_attributes, adjust_svg_attributes,
    E,
    _ReparseException
)


def parse(doc, treebuilder="etree", namespace_html_elements=True, **kwargs):
    """Parse an HTML document as a string or file-like object into a tree

    :arg doc: the document to parse as a string or file-like object

    :arg treebuilder: the treebuilder to use when parsing

    :arg namespace_html_elements: whether or not to namespace HTML elements

    :returns: parsed tree

    Example:

    >>> from html5lib.html5parser import parse
    >>> parse('<html><body><p>This is a doc</p></body></html>')
    <Element u'{http://www.w3.org/1999/xhtml}html' at 0x7feac4909db0>

    """
    tb = treebuilders.get_tree_builder(treebuilder)
    p = HTMLParser(tb, namespace_html_elements=namespace_html_elements)
    return p.parse(doc, **kwargs)


def parse_fragment(doc, container="div", treebuilder="etree", namespace_html_elements=True, **kwargs):
    """Parse an HTML fragment as a string or file-like object into a tree

    :arg doc: the fragment to parse as a string or file-like object

    :arg container: the container context to parse the fragment in

    :arg treebuilder: the treebuilder to use when parsing

    :arg namespace_html_elements: whether or not to namespace HTML elements

    :returns: parsed tree

    Example:

    >>> from html5lib.html5libparser import parse_fragment
    >>> parse_fragment('<b>this is a fragment</b>')
    <Element u'DOCUMENT_FRAGMENT' at 0x7feac484b090>

    """
    tb = treebuilders.get_tree_builder(treebuilder)
    p = HTMLParser(tb, namespace_html_elements=namespace_html_elements)
    return p.parse_fragment(doc, container=container, **kwargs)


def method_decorator_metaclass(function):
    class Decorated(type):
        def __new__(meta, classname, bases, class_dict):
            for attribute_name, attribute in class_dict.items():
                if isinstance(attribute, types.FunctionType):
                    attribute = function(attribute)

                class_dict[attribute_name] = attribute
            return type.__new__(meta, classname, bases, class_dict)
    return Decorated


class HTMLParser(object):
    """HTML parser

    Generates a tree structure from a stream of (possibly malformed) HTML.

    """

    def __init__(self, tree=None, strict=False, namespace_html_elements=True, debug=False):
        """
        :arg tree: a treebuilder class controlling the type of tree that will be
            returned. Built in treebuilders can be accessed through
            html5lib.treebuilders.get_tree_builder(tree_type)

        :arg strict: raise an exception when a parse error is encountered

        :arg namespace_html_elements: whether or not to namespace HTML elements

        :arg debug: whether or not to enable debug mode which logs things

        Example:

        >>> from html5lib.html5parser import HTMLParser
        >>> parser = HTMLParser()                     # generates parser with etree builder
        >>> parser = HTMLParser('lxml', strict=True)  # generates parser with lxml builder which is strict

        """

        # Raise an exception on the first error encountered
        self.strict = strict

        if tree is None:
            tree = treebuilders.get_tree_builder("etree")
        self.tree = tree(namespace_html_elements)
        self.errors = []

        self.phases = {name: cls(self, self.tree) for name, cls in
                       get_phases(debug).items()}

    def _parse(self, stream, inner_html=False, container="div", scripting=False, **kwargs):

        self.inner_html_mode = inner_html
        self.container = container
        self.scripting = scripting
        self.tokenizer = _tokenizer.HTMLTokenizer(stream, parser=self, **kwargs)
        self.reset()

        try:
            self.main_loop()
        except _ReparseException:
            self.reset()
            self.main_loop()

    def reset(self):
        self.tree.reset()
        self.first_start_tag = False
        self.errors = []
        self.log = []  # only used with debug mode
        # "quirks" / "limited quirks" / "no quirks"
        self.compat_mode = "no quirks"

        if self.inner_html_mode:
            self.inner_html = self.container.lower()

            if self.inner_html in cdata_elements:
                self.tokenizer.state = self.tokenizer.rcdata_state
            elif self.inner_html in rcdata_elements:
                self.tokenizer.state = self.tokenizer.rawtext_state
            elif self.inner_html == 'plaintext':
                self.tokenizer.state = self.tokenizer.plaintext_state
            else:
                # state already is data state
                # self.tokenizer.state = self.tokenizer.data_state
                pass
            self.phase = self.phases["before_html"]
            self.phase.insert_html_element()
            self.reset_insertion_mode()
        else:
            self.inner_html = False  # pylint:disable=redefined-variable-type
            self.phase = self.phases["initial"]

        self.last_phase = None

        self.before_rc_data_phase = None

        self.frameset_ok = True

    @property
    def document_encoding(self):
        """Name of the character encoding that was used to decode the input stream, or
        :obj:`None` if that is not determined yet

        """
        if not hasattr(self, 'tokenizer'):
            return None
        return self.tokenizer.stream.char_encoding[0].name

    def is_html_integration_point(self, element):
        if (element.name == "annotation-xml" and
                element.namespace == namespaces["mathml"]):
            return ("encoding" in element.attributes and
                    element.attributes["encoding"].translate(
                        ascii_upper2_lower) in
                    ("text/html", "application/xhtml+xml"))
        else:
            return (element.namespace, element.name) in html_integration_point_elements

    def is_math_ml_text_integration_point(self, element):
        return (element.namespace, element.name) in mathml_text_integration_point_elements

    def main_loop(self):
        CharactersToken = token_types["Characters"]
        SpaceCharactersToken = token_types["SpaceCharacters"]
        StartTagToken = token_types["StartTag"]
        EndTagToken = token_types["EndTag"]
        CommentToken = token_types["Comment"]
        DoctypeToken = token_types["Doctype"]
        ParseErrorToken = token_types["ParseError"]

        for token in self.tokenizer:
            prev_token = None
            new_token = token
            while new_token is not None:
                prev_token = new_token
                current_node = self.tree.open_elements[-1] if self.tree.open_elements else None
                current_node_namespace = current_node.namespace if current_node else None
                current_node_name = current_node.name if current_node else None

                type = new_token["type"]

                if type == ParseErrorToken:
                    self.parse_error(new_token["data"], new_token.get("datavars", {}))
                    new_token = None
                else:
                    if (len(self.tree.open_elements) == 0 or
                        current_node_namespace == self.tree.default_namespace or
                        (self.is_math_ml_text_integration_point(current_node) and
                         ((type == StartTagToken and
                           token["name"] not in frozenset(["mglyph", "malignmark"])) or
                          type in (CharactersToken, SpaceCharactersToken))) or
                        (current_node_namespace == namespaces["mathml"] and
                         current_node_name == "annotation-xml" and
                         type == StartTagToken and
                         token["name"] == "svg") or
                        (self.is_html_integration_point(current_node) and
                         type in (StartTagToken, CharactersToken, SpaceCharactersToken))):
                        phase = self.phase
                    else:
                        phase = self.phases["in_foreign_content"]

                    if type == CharactersToken:
                        new_token = phase.process_characters(new_token)
                    elif type == SpaceCharactersToken:
                        new_token = phase.process_space_characters(new_token)
                    elif type == StartTagToken:
                        new_token = phase.process_start_tag(new_token)
                    elif type == EndTagToken:
                        new_token = phase.process_end_tag(new_token)
                    elif type == CommentToken:
                        new_token = phase.process_comment(new_token)
                    elif type == DoctypeToken:
                        new_token = phase.process_doctype(new_token)

            if (type == StartTagToken and prev_token["self_closing"] and
                    not prev_token["self_closing_acknowledged"]):
                self.parse_error("non-void-element-with-trailing-solidus",
                                {"name": prev_token["name"]})

        # When the loop finishes it's EOF
        reprocess = True
        phases = []
        while reprocess:
            phases.append(self.phase)
            reprocess = self.phase.process_eof()
            if reprocess:
                assert self.phase not in phases

    def parse(self, stream, *args, **kwargs):
        """Parse a HTML document into a well-formed tree

        :arg stream: a file-like object or string containing the HTML to be parsed

            The optional encoding parameter must be a string that indicates
            the encoding.  If specified, that encoding will be used,
            regardless of any BOM or later declaration (such as in a meta
            element).

        :arg scripting: treat noscript elements as if JavaScript was turned on

        :returns: parsed tree

        Example:

        >>> from html5lib.html5parser import HTMLParser
        >>> parser = HTMLParser()
        >>> parser.parse('<html><body><p>This is a doc</p></body></html>')
        <Element u'{http://www.w3.org/1999/xhtml}html' at 0x7feac4909db0>

        """
        self._parse(stream, False, None, *args, **kwargs)
        return self.tree.get_document()

    def parse_fragment(self, stream, *args, **kwargs):
        """Parse a HTML fragment into a well-formed tree fragment

        :arg container: name of the element we're setting the inner_html
            property if set to None, default to 'div'

        :arg stream: a file-like object or string containing the HTML to be parsed

            The optional encoding parameter must be a string that indicates
            the encoding.  If specified, that encoding will be used,
            regardless of any BOM or later declaration (such as in a meta
            element)

        :arg scripting: treat noscript elements as if JavaScript was turned on

        :returns: parsed tree

        Example:

        >>> from html5lib.html5libparser import HTMLParser
        >>> parser = HTMLParser()
        >>> parser.parse_fragment('<b>this is a fragment</b>')
        <Element u'DOCUMENT_FRAGMENT' at 0x7feac484b090>

        """
        self._parse(stream, True, *args, **kwargs)
        return self.tree.get_fragment()

    def parse_error(self, errorcode="XXX-undefined-error", datavars=None):
        # XXX The idea is to make errorcode mandatory.
        if datavars is None:
            datavars = {}
        self.errors.append((self.tokenizer.stream.position(), errorcode, datavars))
        if self.strict:
            raise ParseError(E[errorcode] % datavars)

    def adjust_math_ml_attributes(self, token):
        adjust_attributes(token, adjust_math_ml_attributes)

    def adjust_svg_attributes(self, token):
        adjust_attributes(token, adjust_svg_attributes)

    def adjust_foreign_attributes(self, token):
        adjust_attributes(token, adjust_foreign_attributes_map)

    def reparse_token_normal(self, token):
        # pylint:disable=unused-argument
        self.parser.phase()

    def reset_insertion_mode(self):
        # The name of this method is mostly historical. (It's also used in the
        # specification.)
        last = False
        new_modes = {
            "select": "in_select",
            "td": "in_cell",
            "th": "in_cell",
            "tr": "in_row",
            "tbody": "in_table_body",
            "thead": "in_table_body",
            "tfoot": "in_table_body",
            "caption": "in_caption",
            "colgroup": "in_column_group",
            "table": "in_table",
            "head": "in_body",
            "body": "in_body",
            "frameset": "in_frameset",
            "html": "before_head"
        }
        for node in self.tree.open_elements[::-1]:
            node_name = node.name
            new_phase = None
            if node == self.tree.open_elements[0]:
                assert self.inner_html
                last = True
                node_name = self.inner_html
            # Check for conditions that should only happen in the inner_html
            # case
            if node_name in ("select", "colgroup", "head", "html"):
                assert self.inner_html

            if not last and node.namespace != self.tree.default_namespace:
                continue

            if node_name in new_modes:
                new_phase = self.phases[new_modes[node_name]]
                break
            elif last:
                new_phase = self.phases["in_body"]
                break

        self.phase = new_phase

    def parse_rc_data_rawtext(self, token, content_type):
        # Generic RCDATA/RAWTEXT Parsing algorithm
        assert content_type in ("RAWTEXT", "RCDATA")

        self.tree.insert_element(token)

        if content_type == "RAWTEXT":
            self.tokenizer.state = self.tokenizer.rawtext_state
        else:
            self.tokenizer.state = self.tokenizer.rcdata_state

        self.original_phase = self.phase

        self.phase = self.phases["text"]


@_utils.memoize
def get_phases(debug):
    def log(function):
        """Logger that records which phase processes each token"""
        type_names = {value: key for key, value in token_types.items()}

        def wrapped(self, *args, **kwargs):
            if function.__name__.startswith("process") and len(args) > 0:
                token = args[0]
                info = {"type": type_names[token['type']]}
                if token['type'] in tag_token_types:
                    info["name"] = token['name']

                self.parser.log.append((self.parser.tokenizer.state.__name__,
                                        self.parser.phase.__class__.__name__,
                                        self.__class__.__name__,
                                        function.__name__,
                                        info))
                return function(self, *args, **kwargs)
            else:
                return function(self, *args, **kwargs)
        return wrapped

    def get_metaclass(use_metaclass, metaclass_func):
        if use_metaclass:
            return method_decorator_metaclass(metaclass_func)
        else:
            return type

    # pylint:disable=unused-argument
    class Phase(with_metaclass(get_metaclass(debug, log))):
        """Base class for helper object that implements each phase of processing
        """
        __slots__ = ("parser", "tree", "__start_tag_cache", "__end_tag_cache")

        def __init__(self, parser, tree):
            self.parser = parser
            self.tree = tree
            self.__start_tag_cache = {}
            self.__end_tag_cache = {}

        def process_eof(self):
            raise NotImplementedError

        def process_comment(self, token):
            # For most phases the following is correct. Where it's not it will be
            # overridden.
            self.tree.insert_comment(token, self.tree.open_elements[-1])

        def process_doctype(self, token):
            self.parser.parse_error("unexpected-doctype")

        def process_characters(self, token):
            self.tree.insert_text(token["data"])

        def process_space_characters(self, token):
            self.tree.insert_text(token["data"])

        def process_start_tag(self, token):
            # Note the caching is done here rather than BoundMethodDispatcher as doing it there
            # requires a circular reference to the Phase, and this ends up with a significant
            # (CPython 2.7, 3.8) GC cost when parsing many short inputs
            name = token["name"]
            # In Py2, using `in` is quicker in general than try/except KeyError
            # In Py3, `in` is quicker when there are few cache hits (typically short inputs)
            if name in self.__start_tag_cache:
                func = self.__start_tag_cache[name]
            else:
                func = self.__start_tag_cache[name] = self.start_tag_handler[name]
                # bound the cache size in case we get loads of unknown tags
                while len(self.__start_tag_cache) > len(self.start_tag_handler) * 1.1:
                    # this makes the eviction policy random on Py < 3.7 and FIFO >= 3.7
                    self.__start_tag_cache.pop(next(iter(self.__start_tag_cache)))
            return func(token)

        def start_tag_html(self, token):
            if not self.parser.first_start_tag and token["name"] == "html":
                self.parser.parse_error("non-html-root")
            # XXX Need a check here to see if the first start tag token emitted is
            # this token... If it's not, invoke self.parser.parse_error().
            for attr, value in token["data"].items():
                if attr not in self.tree.open_elements[0].attributes:
                    self.tree.open_elements[0].attributes[attr] = value
            self.parser.first_start_tag = False

        def process_end_tag(self, token):
            # Note the caching is done here rather than BoundMethodDispatcher as doing it there
            # requires a circular reference to the Phase, and this ends up with a significant
            # (CPython 2.7, 3.8) GC cost when parsing many short inputs
            name = token["name"]
            # In Py2, using `in` is quicker in general than try/except KeyError
            # In Py3, `in` is quicker when there are few cache hits (typically short inputs)
            if name in self.__end_tag_cache:
                func = self.__end_tag_cache[name]
            else:
                func = self.__end_tag_cache[name] = self.end_tag_handler[name]
                # bound the cache size in case we get loads of unknown tags
                while len(self.__end_tag_cache) > len(self.end_tag_handler) * 1.1:
                    # this makes the eviction policy random on Py < 3.7 and FIFO >= 3.7
                    self.__end_tag_cache.pop(next(iter(self.__end_tag_cache)))
            return func(token)

    class InitialPhase(Phase):
        __slots__ = tuple()

        def process_space_characters(self, token):
            pass

        def process_comment(self, token):
            self.tree.insert_comment(token, self.tree.document)

        def process_doctype(self, token):
            name = token["name"]
            public_id = token["public_id"]
            system_id = token["system_id"]
            correct = token["correct"]

            if (name != "html" or public_id is not None or
                    system_id is not None and system_id != "about:legacy-compat"):
                self.parser.parse_error("unknown-doctype")

            if public_id is None:
                public_id = ""

            self.tree.insert_doctype(token)

            if public_id != "":
                public_id = public_id.translate(ascii_upper2_lower)

            if (not correct or token["name"] != "html" or
                    public_id.startswith(
                        ("+//silmaril//dtd html pro v0r11 19970101//",
                         "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
                         "-//as//dtd html 3.0 aswedit + extensions//",
                         "-//ietf//dtd html 2.0 level 1//",
                         "-//ietf//dtd html 2.0 level 2//",
                         "-//ietf//dtd html 2.0 strict level 1//",
                         "-//ietf//dtd html 2.0 strict level 2//",
                         "-//ietf//dtd html 2.0 strict//",
                         "-//ietf//dtd html 2.0//",
                         "-//ietf//dtd html 2.1e//",
                         "-//ietf//dtd html 3.0//",
                         "-//ietf//dtd html 3.2 final//",
                         "-//ietf//dtd html 3.2//",
                         "-//ietf//dtd html 3//",
                         "-//ietf//dtd html level 0//",
                         "-//ietf//dtd html level 1//",
                         "-//ietf//dtd html level 2//",
                         "-//ietf//dtd html level 3//",
                         "-//ietf//dtd html strict level 0//",
                         "-//ietf//dtd html strict level 1//",
                         "-//ietf//dtd html strict level 2//",
                         "-//ietf//dtd html strict level 3//",
                         "-//ietf//dtd html strict//",
                         "-//ietf//dtd html//",
                         "-//metrius//dtd metrius presentational//",
                         "-//microsoft//dtd internet explorer 2.0 html strict//",
                         "-//microsoft//dtd internet explorer 2.0 html//",
                         "-//microsoft//dtd internet explorer 2.0 tables//",
                         "-//microsoft//dtd internet explorer 3.0 html strict//",
                         "-//microsoft//dtd internet explorer 3.0 html//",
                         "-//microsoft//dtd internet explorer 3.0 tables//",
                         "-//netscape comm. corp.//dtd html//",
                         "-//netscape comm. corp.//dtd strict html//",
                         "-//o'reilly and associates//dtd html 2.0//",
                         "-//o'reilly and associates//dtd html extended 1.0//",
                         "-//o'reilly and associates//dtd html extended relaxed 1.0//",
                         "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
                         "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
                         "-//spyglass//dtd html 2.0 extended//",
                         "-//sq//dtd html 2.0 hotmetal + extensions//",
                         "-//sun microsystems corp.//dtd hotjava html//",
                         "-//sun microsystems corp.//dtd hotjava strict html//",
                         "-//w3c//dtd html 3 1995-03-24//",
                         "-//w3c//dtd html 3.2 draft//",
                         "-//w3c//dtd html 3.2 final//",
                         "-//w3c//dtd html 3.2//",
                         "-//w3c//dtd html 3.2s draft//",
                         "-//w3c//dtd html 4.0 frameset//",
                         "-//w3c//dtd html 4.0 transitional//",
                         "-//w3c//dtd html experimental 19960712//",
                         "-//w3c//dtd html experimental 970421//",
                         "-//w3c//dtd w3 html//",
                         "-//w3o//dtd w3 html 3.0//",
                         "-//webtechs//dtd mozilla html 2.0//",
                         "-//webtechs//dtd mozilla html//")) or
                    public_id in ("-//w3o//dtd w3 html strict 3.0//en//",
                                 "-/w3c/dtd html 4.0 transitional/en",
                                 "html") or
                    public_id.startswith(
                        ("-//w3c//dtd html 4.01 frameset//",
                         "-//w3c//dtd html 4.01 transitional//")) and
                    system_id is None or
                    system_id and system_id.lower() == "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"):
                self.parser.compat_mode = "quirks"
            elif (public_id.startswith(
                    ("-//w3c//dtd xhtml 1.0 frameset//",
                     "-//w3c//dtd xhtml 1.0 transitional//")) or
                  public_id.startswith(
                      ("-//w3c//dtd html 4.01 frameset//",
                       "-//w3c//dtd html 4.01 transitional//")) and
                  system_id is not None):
                self.parser.compat_mode = "limited quirks"

            self.parser.phase = self.parser.phases["before_html"]

        def anything_else(self):
            self.parser.compat_mode = "quirks"
            self.parser.phase = self.parser.phases["before_html"]

        def process_characters(self, token):
            self.parser.parse_error("expected-doctype-but-got-chars")
            self.anything_else()
            return token

        def process_start_tag(self, token):
            self.parser.parse_error("expected-doctype-but-got-start-tag",
                                   {"name": token["name"]})
            self.anything_else()
            return token

        def process_end_tag(self, token):
            self.parser.parse_error("expected-doctype-but-got-end-tag",
                                   {"name": token["name"]})
            self.anything_else()
            return token

        def process_eof(self):
            self.parser.parse_error("expected-doctype-but-got-eof")
            self.anything_else()
            return True

    class BeforeHtmlPhase(Phase):
        __slots__ = tuple()

        # helper methods
        def insert_html_element(self):
            self.tree.insert_root(implied_tag_token("html", "StartTag"))
            self.parser.phase = self.parser.phases["before_head"]

        # other
        def process_eof(self):
            self.insert_html_element()
            return True

        def process_comment(self, token):
            self.tree.insert_comment(token, self.tree.document)

        def process_space_characters(self, token):
            pass

        def process_characters(self, token):
            self.insert_html_element()
            return token

        def process_start_tag(self, token):
            if token["name"] == "html":
                self.parser.first_start_tag = True
            self.insert_html_element()
            return token

        def process_end_tag(self, token):
            if token["name"] not in ("head", "body", "html", "br"):
                self.parser.parse_error("unexpected-end-tag-before-html",
                                       {"name": token["name"]})
            else:
                self.insert_html_element()
                return token

    class BeforeHeadPhase(Phase):
        __slots__ = tuple()

        def process_eof(self):
            self.start_tag_head(implied_tag_token("head", "StartTag"))
            return True

        def process_space_characters(self, token):
            pass

        def process_characters(self, token):
            self.start_tag_head(implied_tag_token("head", "StartTag"))
            return token

        def start_tag_html(self, token):
            return self.parser.phases["in_body"].process_start_tag(token)

        def start_tag_head(self, token):
            self.tree.insert_element(token)
            self.tree.head_pointer = self.tree.open_elements[-1]
            self.parser.phase = self.parser.phases["in_head"]

        def start_tag_other(self, token):
            self.start_tag_head(implied_tag_token("head", "StartTag"))
            return token

        def end_tag_imply_head(self, token):
            self.start_tag_head(implied_tag_token("head", "StartTag"))
            return token

        def end_tag_other(self, token):
            self.parser.parse_error("end-tag-after-implied-root",
                                   {"name": token["name"]})

        start_tag_handler = _utils.MethodDispatcher([
            ("html", start_tag_html),
            ("head", start_tag_head)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            (("head", "body", "html", "br"), end_tag_imply_head)
        ])
        end_tag_handler.default = end_tag_other

    class InHeadPhase(Phase):
        __slots__ = tuple()

        # the real thing
        def process_eof(self):
            self.anything_else()
            return True

        def process_characters(self, token):
            self.anything_else()
            return token

        def start_tag_html(self, token):
            return self.parser.phases["in_body"].process_start_tag(token)

        def start_tag_head(self, token):
            self.parser.parse_error("two-heads-are-not-better-than-one")

        def start_tag_base_link_command(self, token):
            self.tree.insert_element(token)
            self.tree.open_elements.pop()
            token["self_closing_acknowledged"] = True

        def start_tag_meta(self, token):
            self.tree.insert_element(token)
            self.tree.open_elements.pop()
            token["self_closing_acknowledged"] = True

            attributes = token["data"]
            if self.parser.tokenizer.stream.char_encoding[1] == "tentative":
                if "charset" in attributes:
                    self.parser.tokenizer.stream.change_encoding(attributes["charset"])
                elif ("content" in attributes and
                      "http-equiv" in attributes and
                      attributes["http-equiv"].lower() == "content-type"):
                    # Encoding it as UTF-8 here is a hack, as really we should pass
                    # the abstract Unicode string, and just use the
                    # ContentAttrParser on that, but using UTF-8 allows all chars
                    # to be encoded and as a ASCII-superset works.
                    data = _inputstream.EncodingBytes(attributes["content"].encode("utf-8"))
                    parser = _inputstream.ContentAttrParser(data)
                    codec = parser.parse()
                    self.parser.tokenizer.stream.change_encoding(codec)

        def start_tag_title(self, token):
            self.parser.parse_rc_data_rawtext(token, "RCDATA")

        def start_tag_no_frames_style(self, token):
            # Need to decide whether to implement the scripting-disabled case
            self.parser.parse_rc_data_rawtext(token, "RAWTEXT")

        def start_tag_noscript(self, token):
            if self.parser.scripting:
                self.parser.parse_rc_data_rawtext(token, "RAWTEXT")
            else:
                self.tree.insert_element(token)
                self.parser.phase = self.parser.phases["in_head_noscript"]

        def start_tag_script(self, token):
            self.tree.insert_element(token)
            self.parser.tokenizer.state = self.parser.tokenizer.script_data_state
            self.parser.original_phase = self.parser.phase
            self.parser.phase = self.parser.phases["text"]

        def start_tag_other(self, token):
            self.anything_else()
            return token

        def end_tag_head(self, token):
            node = self.parser.tree.open_elements.pop()
            assert node.name == "head", "Expected head got %s" % node.name
            self.parser.phase = self.parser.phases["after_head"]

        def end_tag_html_body_br(self, token):
            self.anything_else()
            return token

        def end_tag_other(self, token):
            self.parser.parse_error("unexpected-end-tag", {"name": token["name"]})

        def anything_else(self):
            self.end_tag_head(implied_tag_token("head"))

        start_tag_handler = _utils.MethodDispatcher([
            ("html", start_tag_html),
            ("title", start_tag_title),
            (("noframes", "style"), start_tag_no_frames_style),
            ("noscript", start_tag_noscript),
            ("script", start_tag_script),
            (("base", "basefont", "bgsound", "command", "link"),
             start_tag_base_link_command),
            ("meta", start_tag_meta),
            ("head", start_tag_head)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            ("head", end_tag_head),
            (("br", "html", "body"), end_tag_html_body_br)
        ])
        end_tag_handler.default = end_tag_other

    class InHeadNoscriptPhase(Phase):
        __slots__ = tuple()

        def process_eof(self):
            self.parser.parse_error("eof-in-head-noscript")
            self.anything_else()
            return True

        def process_comment(self, token):
            return self.parser.phases["in_head"].process_comment(token)

        def process_characters(self, token):
            self.parser.parse_error("char-in-head-noscript")
            self.anything_else()
            return token

        def process_space_characters(self, token):
            return self.parser.phases["in_head"].process_space_characters(token)

        def start_tag_html(self, token):
            return self.parser.phases["in_body"].process_start_tag(token)

        def start_tag_base_link_command(self, token):
            return self.parser.phases["in_head"].process_start_tag(token)

        def start_tag_head_noscript(self, token):
            self.parser.parse_error("unexpected-start-tag", {"name": token["name"]})

        def start_tag_other(self, token):
            self.parser.parse_error("unexpected-inhead-noscript-tag", {"name": token["name"]})
            self.anything_else()
            return token

        def end_tag_noscript(self, token):
            node = self.parser.tree.open_elements.pop()
            assert node.name == "noscript", "Expected noscript got %s" % node.name
            self.parser.phase = self.parser.phases["in_head"]

        def end_tag_br(self, token):
            self.parser.parse_error("unexpected-inhead-noscript-tag", {"name": token["name"]})
            self.anything_else()
            return token

        def end_tag_other(self, token):
            self.parser.parse_error("unexpected-end-tag", {"name": token["name"]})

        def anything_else(self):
            # Caller must raise parse error first!
            self.end_tag_noscript(implied_tag_token("noscript"))

        start_tag_handler = _utils.MethodDispatcher([
            ("html", start_tag_html),
            (("basefont", "bgsound", "link", "meta", "noframes", "style"), start_tag_base_link_command),
            (("head", "noscript"), start_tag_head_noscript),
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            ("noscript", end_tag_noscript),
            ("br", end_tag_br),
        ])
        end_tag_handler.default = end_tag_other

    class AfterHeadPhase(Phase):
        __slots__ = tuple()

        def process_eof(self):
            self.anything_else()
            return True

        def process_characters(self, token):
            self.anything_else()
            return token

        def start_tag_html(self, token):
            return self.parser.phases["in_body"].process_start_tag(token)

        def start_tag_body(self, token):
            self.parser.frameset_ok = False
            self.tree.insert_element(token)
            self.parser.phase = self.parser.phases["in_body"]

        def start_tag_frameset(self, token):
            self.tree.insert_element(token)
            self.parser.phase = self.parser.phases["in_frameset"]

        def start_tag_from_head(self, token):
            self.parser.parse_error("unexpected-start-tag-out-of-my-head",
                                   {"name": token["name"]})
            self.tree.open_elements.append(self.tree.head_pointer)
            self.parser.phases["in_head"].process_start_tag(token)
            for node in self.tree.open_elements[::-1]:
                if node.name == "head":
                    self.tree.open_elements.remove(node)
                    break

        def start_tag_head(self, token):
            self.parser.parse_error("unexpected-start-tag", {"name": token["name"]})

        def start_tag_other(self, token):
            self.anything_else()
            return token

        def end_tag_html_body_br(self, token):
            self.anything_else()
            return token

        def end_tag_other(self, token):
            self.parser.parse_error("unexpected-end-tag", {"name": token["name"]})

        def anything_else(self):
            self.tree.insert_element(implied_tag_token("body", "StartTag"))
            self.parser.phase = self.parser.phases["in_body"]
            self.parser.frameset_ok = True

        start_tag_handler = _utils.MethodDispatcher([
            ("html", start_tag_html),
            ("body", start_tag_body),
            ("frameset", start_tag_frameset),
            (("base", "basefont", "bgsound", "link", "meta", "noframes", "script",
              "style", "title"),
             start_tag_from_head),
            ("head", start_tag_head)
        ])
        start_tag_handler.default = start_tag_other
        end_tag_handler = _utils.MethodDispatcher([(("body", "html", "br"),
                                                  end_tag_html_body_br)])
        end_tag_handler.default = end_tag_other

    class InBodyPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inbody
        # the really-really-really-very crazy mode
        __slots__ = ("process_space_characters",)

        def __init__(self, *args, **kwargs):
            super(InBodyPhase, self).__init__(*args, **kwargs)
            # Set this to the default handler
            self.process_space_characters = self.process_space_characters_non_pre

        def is_matching_formatting_element(self, node1, node2):
            return (node1.name == node2.name and
                    node1.namespace == node2.namespace and
                    node1.attributes == node2.attributes)

        # helper
        def add_formatting_element(self, token):
            self.tree.insert_element(token)
            element = self.tree.open_elements[-1]

            matching_elements = []
            for node in self.tree.active_formatting_elements[::-1]:
                if node is Marker:
                    break
                elif self.is_matching_formatting_element(node, element):
                    matching_elements.append(node)

            assert len(matching_elements) <= 3
            if len(matching_elements) == 3:
                self.tree.active_formatting_elements.remove(matching_elements[-1])
            self.tree.active_formatting_elements.append(element)

        # the real deal
        def process_eof(self):
            allowed_elements = frozenset(("dd", "dt", "li", "p", "tbody", "td",
                                          "tfoot", "th", "thead", "tr", "body",
                                          "html"))
            for node in self.tree.open_elements[::-1]:
                if node.name not in allowed_elements:
                    self.parser.parse_error("expected-closing-tag-but-got-eof")
                    break
            # Stop parsing

        def process_space_characters_drop_newline(self, token):
            # Sometimes (start of <pre>, <listing>, and <textarea> blocks) we
            # want to drop leading newlines
            data = token["data"]
            self.process_space_characters = self.process_space_characters_non_pre
            if (data.startswith("\n") and
                self.tree.open_elements[-1].name in ("pre", "listing", "textarea") and
                    not self.tree.open_elements[-1].has_content()):
                data = data[1:]
            if data:
                self.tree.reconstruct_active_formatting_elements()
                self.tree.insert_text(data)

        def process_characters(self, token):
            if token["data"] == "\u0000":
                # The tokenizer should always emit null on its own
                return
            self.tree.reconstruct_active_formatting_elements()
            self.tree.insert_text(token["data"])
            # This must be bad for performance
            if (self.parser.frameset_ok and
                any([char not in space_characters
                     for char in token["data"]])):
                self.parser.frameset_ok = False

        def process_space_characters_non_pre(self, token):
            self.tree.reconstruct_active_formatting_elements()
            self.tree.insert_text(token["data"])

        def start_tag_process_in_head(self, token):
            return self.parser.phases["in_head"].process_start_tag(token)

        def start_tag_body(self, token):
            self.parser.parse_error("unexpected-start-tag", {"name": "body"})
            if (len(self.tree.open_elements) == 1 or
                    self.tree.open_elements[1].name != "body"):
                assert self.parser.inner_html
            else:
                self.parser.frameset_ok = False
                for attr, value in token["data"].items():
                    if attr not in self.tree.open_elements[1].attributes:
                        self.tree.open_elements[1].attributes[attr] = value

        def start_tag_frameset(self, token):
            self.parser.parse_error("unexpected-start-tag", {"name": "frameset"})
            if (len(self.tree.open_elements) == 1 or self.tree.open_elements[1].name != "body"):
                assert self.parser.inner_html
            elif not self.parser.frameset_ok:
                pass
            else:
                if self.tree.open_elements[1].parent:
                    self.tree.open_elements[1].parent.remove_child(self.tree.open_elements[1])
                while self.tree.open_elements[-1].name != "html":
                    self.tree.open_elements.pop()
                self.tree.insert_element(token)
                self.parser.phase = self.parser.phases["in_frameset"]

        def start_tag_close_p(self, token):
            if self.tree.element_in_scope("p", variant="button"):
                self.end_tag_p(implied_tag_token("p"))
            self.tree.insert_element(token)

        def start_tag_pre_listing(self, token):
            if self.tree.element_in_scope("p", variant="button"):
                self.end_tag_p(implied_tag_token("p"))
            self.tree.insert_element(token)
            self.parser.frameset_ok = False
            self.process_space_characters = self.process_space_characters_drop_newline

        def start_tag_form(self, token):
            if self.tree.form_pointer:
                self.parser.parse_error("unexpected-start-tag", {"name": "form"})
            else:
                if self.tree.element_in_scope("p", variant="button"):
                    self.end_tag_p(implied_tag_token("p"))
                self.tree.insert_element(token)
                self.tree.form_pointer = self.tree.open_elements[-1]

        def start_tag_list_item(self, token):
            self.parser.frameset_ok = False

            stop_names_map = {"li": ["li"],
                            "dt": ["dt", "dd"],
                            "dd": ["dt", "dd"]}
            stop_names = stop_names_map[token["name"]]
            for node in reversed(self.tree.open_elements):
                if node.name in stop_names:
                    self.parser.phase.process_end_tag(
                        implied_tag_token(node.name, "EndTag"))
                    break
                if (node.name_tuple in special_elements and
                        node.name not in ("address", "div", "p")):
                    break

            if self.tree.element_in_scope("p", variant="button"):
                self.parser.phase.process_end_tag(
                    implied_tag_token("p", "EndTag"))

            self.tree.insert_element(token)

        def start_tag_plaintext(self, token):
            if self.tree.element_in_scope("p", variant="button"):
                self.end_tag_p(implied_tag_token("p"))
            self.tree.insert_element(token)
            self.parser.tokenizer.state = self.parser.tokenizer.plaintext_state

        def start_tag_heading(self, token):
            if self.tree.element_in_scope("p", variant="button"):
                self.end_tag_p(implied_tag_token("p"))
            if self.tree.open_elements[-1].name in heading_elements:
                self.parser.parse_error("unexpected-start-tag", {"name": token["name"]})
                self.tree.open_elements.pop()
            self.tree.insert_element(token)

        def start_tag_a(self, token):
            afe_a_element = self.tree.element_in_active_formatting_elements("a")
            if afe_a_element:
                self.parser.parse_error("unexpected-start-tag-implies-end-tag",
                                       {"start_name": "a", "end_name": "a"})
                self.end_tag_formatting(implied_tag_token("a"))
                if afe_a_element in self.tree.open_elements:
                    self.tree.open_elements.remove(afe_a_element)
                if afe_a_element in self.tree.active_formatting_elements:
                    self.tree.active_formatting_elements.remove(afe_a_element)
            self.tree.reconstruct_active_formatting_elements()
            self.add_formatting_element(token)

        def start_tag_formatting(self, token):
            self.tree.reconstruct_active_formatting_elements()
            self.add_formatting_element(token)

        def start_tag_nobr(self, token):
            self.tree.reconstruct_active_formatting_elements()
            if self.tree.element_in_scope("nobr"):
                self.parser.parse_error("unexpected-start-tag-implies-end-tag",
                                       {"start_name": "nobr", "end_name": "nobr"})
                self.process_end_tag(implied_tag_token("nobr"))
                # XXX Need tests that trigger the following
                self.tree.reconstruct_active_formatting_elements()
            self.add_formatting_element(token)

        def start_tag_button(self, token):
            if self.tree.element_in_scope("button"):
                self.parser.parse_error("unexpected-start-tag-implies-end-tag",
                                       {"start_name": "button", "end_name": "button"})
                self.process_end_tag(implied_tag_token("button"))
                return token
            else:
                self.tree.reconstruct_active_formatting_elements()
                self.tree.insert_element(token)
                self.parser.frameset_ok = False

        def start_tag_applet_marquee_object(self, token):
            self.tree.reconstruct_active_formatting_elements()
            self.tree.insert_element(token)
            self.tree.active_formatting_elements.append(Marker)
            self.parser.frameset_ok = False

        def start_tag_xmp(self, token):
            if self.tree.element_in_scope("p", variant="button"):
                self.end_tag_p(implied_tag_token("p"))
            self.tree.reconstruct_active_formatting_elements()
            self.parser.frameset_ok = False
            self.parser.parse_rc_data_rawtext(token, "RAWTEXT")

        def start_tag_table(self, token):
            if self.parser.compat_mode != "quirks":
                if self.tree.element_in_scope("p", variant="button"):
                    self.process_end_tag(implied_tag_token("p"))
            self.tree.insert_element(token)
            self.parser.frameset_ok = False
            self.parser.phase = self.parser.phases["in_table"]

        def start_tag_void_formatting(self, token):
            self.tree.reconstruct_active_formatting_elements()
            self.tree.insert_element(token)
            self.tree.open_elements.pop()
            token["self_closing_acknowledged"] = True
            self.parser.frameset_ok = False

        def start_tag_input(self, token):
            frameset_ok = self.parser.frameset_ok
            self.start_tag_void_formatting(token)
            if ("type" in token["data"] and
                    token["data"]["type"].translate(ascii_upper2_lower) == "hidden"):
                # input type=hidden doesn't change frameset_ok
                self.parser.frameset_ok = frameset_ok

        def start_tag_param_source(self, token):
            self.tree.insert_element(token)
            self.tree.open_elements.pop()
            token["self_closing_acknowledged"] = True

        def start_tag_hr(self, token):
            if self.tree.element_in_scope("p", variant="button"):
                self.end_tag_p(implied_tag_token("p"))
            self.tree.insert_element(token)
            self.tree.open_elements.pop()
            token["self_closing_acknowledged"] = True
            self.parser.frameset_ok = False

        def start_tag_image(self, token):
            # No really...
            self.parser.parse_error("unexpected-start-tag-treated-as",
                                   {"original_name": "image", "new_name": "img"})
            self.process_start_tag(implied_tag_token("img", "StartTag",
                                                 attributes=token["data"],
                                                 self_closing=token["self_closing"]))

        def start_tag_is_index(self, token):
            self.parser.parse_error("deprecated-tag", {"name": "isindex"})
            if self.tree.form_pointer:
                return
            form_attrs = {}
            if "action" in token["data"]:
                form_attrs["action"] = token["data"]["action"]
            self.process_start_tag(implied_tag_token("form", "StartTag",
                                                 attributes=form_attrs))
            self.process_start_tag(implied_tag_token("hr", "StartTag"))
            self.process_start_tag(implied_tag_token("label", "StartTag"))
            # XXX Localization ...
            if "prompt" in token["data"]:
                prompt = token["data"]["prompt"]
            else:
                prompt = "This is a searchable index. Enter search keywords: "
            self.process_characters(
                {"type": token_types["Characters"], "data": prompt})
            attributes = token["data"].copy()
            if "action" in attributes:
                del attributes["action"]
            if "prompt" in attributes:
                del attributes["prompt"]
            attributes["name"] = "isindex"
            self.process_start_tag(implied_tag_token("input", "StartTag",
                                                 attributes=attributes,
                                                 self_closing=token["self_closing"]))
            self.process_end_tag(implied_tag_token("label"))
            self.process_start_tag(implied_tag_token("hr", "StartTag"))
            self.process_end_tag(implied_tag_token("form"))

        def start_tag_textarea(self, token):
            self.tree.insert_element(token)
            self.parser.tokenizer.state = self.parser.tokenizer.rcdata_state
            self.process_space_characters = self.process_space_characters_drop_newline
            self.parser.frameset_ok = False

        def start_tag_i_frame(self, token):
            self.parser.frameset_ok = False
            self.start_tag_rawtext(token)

        def start_tag_noscript(self, token):
            if self.parser.scripting:
                self.start_tag_rawtext(token)
            else:
                self.start_tag_other(token)

        def start_tag_rawtext(self, token):
            """iframe, noembed noframes, noscript(if scripting enabled)"""
            self.parser.parse_rc_data_rawtext(token, "RAWTEXT")

        def start_tag_opt(self, token):
            if self.tree.open_elements[-1].name == "option":
                self.parser.phase.process_end_tag(implied_tag_token("option"))
            self.tree.reconstruct_active_formatting_elements()
            self.parser.tree.insert_element(token)

        def start_tag_select(self, token):
            self.tree.reconstruct_active_formatting_elements()
            self.tree.insert_element(token)
            self.parser.frameset_ok = False
            if self.parser.phase in (self.parser.phases["in_table"],
                                     self.parser.phases["in_caption"],
                                     self.parser.phases["in_column_group"],
                                     self.parser.phases["in_table_body"],
                                     self.parser.phases["in_row"],
                                     self.parser.phases["in_cell"]):
                self.parser.phase = self.parser.phases["in_select_in_table"]
            else:
                self.parser.phase = self.parser.phases["in_select"]

        def start_tag_rp_rt(self, token):
            if self.tree.element_in_scope("ruby"):
                self.tree.generate_implied_end_tags()
                if self.tree.open_elements[-1].name != "ruby":
                    self.parser.parse_error()
            self.tree.insert_element(token)

        def start_tag_math(self, token):
            self.tree.reconstruct_active_formatting_elements()
            self.parser.adjust_math_ml_attributes(token)
            self.parser.adjust_foreign_attributes(token)
            token["namespace"] = namespaces["mathml"]
            self.tree.insert_element(token)
            # Need to get the parse error right for the case where the token
            # has a namespace not equal to the xmlns attribute
            if token["self_closing"]:
                self.tree.open_elements.pop()
                token["self_closing_acknowledged"] = True

        def start_tag_svg(self, token):
            self.tree.reconstruct_active_formatting_elements()
            self.parser.adjust_svg_attributes(token)
            self.parser.adjust_foreign_attributes(token)
            token["namespace"] = namespaces["svg"]
            self.tree.insert_element(token)
            # Need to get the parse error right for the case where the token
            # has a namespace not equal to the xmlns attribute
            if token["self_closing"]:
                self.tree.open_elements.pop()
                token["self_closing_acknowledged"] = True

        def start_tag_misplaced(self, token):
            """ Elements that should be children of other elements that have a
            different insertion mode; here they are ignored
            "caption", "col", "colgroup", "frame", "frameset", "head",
            "option", "optgroup", "tbody", "td", "tfoot", "th", "thead",
            "tr", "noscript"
            """
            self.parser.parse_error("unexpected-start-tag-ignored", {"name": token["name"]})

        def start_tag_other(self, token):
            self.tree.reconstruct_active_formatting_elements()
            self.tree.insert_element(token)

        def end_tag_p(self, token):
            if not self.tree.element_in_scope("p", variant="button"):
                self.start_tag_close_p(implied_tag_token("p", "StartTag"))
                self.parser.parse_error("unexpected-end-tag", {"name": "p"})
                self.end_tag_p(implied_tag_token("p", "EndTag"))
            else:
                self.tree.generate_implied_end_tags("p")
                if self.tree.open_elements[-1].name != "p":
                    self.parser.parse_error("unexpected-end-tag", {"name": "p"})
                node = self.tree.open_elements.pop()
                while node.name != "p":
                    node = self.tree.open_elements.pop()

        def end_tag_body(self, token):
            if not self.tree.element_in_scope("body"):
                self.parser.parse_error()
                return
            elif self.tree.open_elements[-1].name != "body":
                for node in self.tree.open_elements[2:]:
                    if node.name not in frozenset(("dd", "dt", "li", "optgroup",
                                                   "option", "p", "rp", "rt",
                                                   "tbody", "td", "tfoot",
                                                   "th", "thead", "tr", "body",
                                                   "html")):
                        # Not sure this is the correct name for the parse error
                        self.parser.parse_error(
                            "expected-one-end-tag-but-got-another",
                            {"got_name": "body", "expected_name": node.name})
                        break
            self.parser.phase = self.parser.phases["after_body"]

        def end_tag_html(self, token):
            # We repeat the test for the body end tag token being ignored here
            if self.tree.element_in_scope("body"):
                self.end_tag_body(implied_tag_token("body"))
                return token

        def end_tag_block(self, token):
            # Put us back in the right whitespace handling mode
            if token["name"] == "pre":
                self.process_space_characters = self.process_space_characters_non_pre
            in_scope = self.tree.element_in_scope(token["name"])
            if in_scope:
                self.tree.generate_implied_end_tags()
            if self.tree.open_elements[-1].name != token["name"]:
                self.parser.parse_error("end-tag-too-early", {"name": token["name"]})
            if in_scope:
                node = self.tree.open_elements.pop()
                while node.name != token["name"]:
                    node = self.tree.open_elements.pop()

        def end_tag_form(self, token):
            node = self.tree.form_pointer
            self.tree.form_pointer = None
            if node is None or not self.tree.element_in_scope(node):
                self.parser.parse_error("unexpected-end-tag",
                                       {"name": "form"})
            else:
                self.tree.generate_implied_end_tags()
                if self.tree.open_elements[-1] != node:
                    self.parser.parse_error("end-tag-too-early-ignored",
                                           {"name": "form"})
                self.tree.open_elements.remove(node)

        def end_tag_list_item(self, token):
            if token["name"] == "li":
                variant = "list"
            else:
                variant = None
            if not self.tree.element_in_scope(token["name"], variant=variant):
                self.parser.parse_error("unexpected-end-tag", {"name": token["name"]})
            else:
                self.tree.generate_implied_end_tags(exclude=token["name"])
                if self.tree.open_elements[-1].name != token["name"]:
                    self.parser.parse_error(
                        "end-tag-too-early",
                        {"name": token["name"]})
                node = self.tree.open_elements.pop()
                while node.name != token["name"]:
                    node = self.tree.open_elements.pop()

        def end_tag_heading(self, token):
            for item in heading_elements:
                if self.tree.element_in_scope(item):
                    self.tree.generate_implied_end_tags()
                    break
            if self.tree.open_elements[-1].name != token["name"]:
                self.parser.parse_error("end-tag-too-early", {"name": token["name"]})

            for item in heading_elements:
                if self.tree.element_in_scope(item):
                    item = self.tree.open_elements.pop()
                    while item.name not in heading_elements:
                        item = self.tree.open_elements.pop()
                    break

        def end_tag_formatting(self, token):
            """The much-feared adoption agency algorithm"""
            # http://svn.whatwg.org/webapps/complete.html#adoption_agency revision 7867
            # XXX Better parse_error messages appreciated.

            # Step 1
            outer_loop_counter = 0

            # Step 2
            while outer_loop_counter < 8:

                # Step 3
                outer_loop_counter += 1

                # Step 4:

                # Let the formatting element be the last element in
                # the list of active formatting elements that:
                # - is between the end of the list and the last scope
                # marker in the list, if any, or the start of the list
                # otherwise, and
                # - has the same tag name as the token.
                formatting_element = self.tree.element_in_active_formatting_elements(
                    token["name"])
                if (not formatting_element or
                    (formatting_element in self.tree.open_elements and
                     not self.tree.element_in_scope(formatting_element.name))):
                    # If there is no such node, then abort these steps
                    # and instead act as described in the "any other
                    # end tag" entry below.
                    self.end_tag_other(token)
                    return

                # Otherwise, if there is such a node, but that node is
                # not in the stack of open elements, then this is a
                # parse error; remove the element from the list, and
                # abort these steps.
                elif formatting_element not in self.tree.open_elements:
                    self.parser.parse_error("adoption-agency-1.2", {"name": token["name"]})
                    self.tree.active_formatting_elements.remove(formatting_element)
                    return

                # Otherwise, if there is such a node, and that node is
                # also in the stack of open elements, but the element
                # is not in scope, then this is a parse error; ignore
                # the token, and abort these steps.
                elif not self.tree.element_in_scope(formatting_element.name):
                    self.parser.parse_error("adoption-agency-4.4", {"name": token["name"]})
                    return

                # Otherwise, there is a formatting element and that
                # element is in the stack and is in scope. If the
                # element is not the current node, this is a parse
                # error. In any case, proceed with the algorithm as
                # written in the following steps.
                else:
                    if formatting_element != self.tree.open_elements[-1]:
                        self.parser.parse_error("adoption-agency-1.3", {"name": token["name"]})

                # Step 5:

                # Let the furthest block be the topmost node in the
                # stack of open elements that is lower in the stack
                # than the formatting element, and is an element in
                # the special category. There might not be one.
                afe_index = self.tree.open_elements.index(formatting_element)
                furthest_block = None
                for element in self.tree.open_elements[afe_index:]:
                    if element.name_tuple in special_elements:
                        furthest_block = element
                        break

                # Step 6:

                # If there is no furthest block, then the UA must
                # first pop all the nodes from the bottom of the stack
                # of open elements, from the current node up to and
                # including the formatting element, then remove the
                # formatting element from the list of active
                # formatting elements, and finally abort these steps.
                if furthest_block is None:
                    element = self.tree.open_elements.pop()
                    while element != formatting_element:
                        element = self.tree.open_elements.pop()
                    self.tree.active_formatting_elements.remove(element)
                    return

                # Step 7
                common_ancestor = self.tree.open_elements[afe_index - 1]

                # Step 8:
                # The bookmark is supposed to help us identify where to reinsert
                # nodes in step 15. We have to ensure that we reinsert nodes after
                # the node before the active formatting element. Note the bookmark
                # can move in step 9.7
                bookmark = self.tree.active_formatting_elements.index(formatting_element)

                # Step 9
                last_node = node = furthest_block
                inner_loop_counter = 0

                index = self.tree.open_elements.index(node)
                while inner_loop_counter < 3:
                    inner_loop_counter += 1
                    # Node is element before node in open elements
                    index -= 1
                    node = self.tree.open_elements[index]
                    if node not in self.tree.active_formatting_elements:
                        self.tree.open_elements.remove(node)
                        continue
                    # Step 9.6
                    if node == formatting_element:
                        break
                    # Step 9.7
                    if last_node == furthest_block:
                        bookmark = self.tree.active_formatting_elements.index(node) + 1
                    # Step 9.8
                    clone = node.clone_node()
                    # Replace node with clone
                    self.tree.active_formatting_elements[
                        self.tree.active_formatting_elements.index(node)] = clone
                    self.tree.open_elements[
                        self.tree.open_elements.index(node)] = clone
                    node = clone
                    # Step 9.9
                    # Remove last_node from its parents, if any
                    if last_node.parent:
                        last_node.parent.remove_child(last_node)
                    node.append_child(last_node)
                    # Step 9.10
                    last_node = node

                # Step 10
                # Foster parent last_node if common_ancestor is a
                # table, tbody, tfoot, thead, or tr we need to foster
                # parent the last_node
                if last_node.parent:
                    last_node.parent.remove_child(last_node)

                if common_ancestor.name in frozenset(("table", "tbody", "tfoot", "thead", "tr")):
                    parent, insert_before = self.tree.get_table_misnested_node_position()
                    parent.insert_before(last_node, insert_before)
                else:
                    common_ancestor.append_child(last_node)

                # Step 11
                clone = formatting_element.clone_node()

                # Step 12
                furthest_block.reparent_children(clone)

                # Step 13
                furthest_block.append_child(clone)

                # Step 14
                self.tree.active_formatting_elements.remove(formatting_element)
                self.tree.active_formatting_elements.insert(bookmark, clone)

                # Step 15
                self.tree.open_elements.remove(formatting_element)
                self.tree.open_elements.insert(
                    self.tree.open_elements.index(furthest_block) + 1, clone)

        def end_tag_applet_marquee_object(self, token):
            if self.tree.element_in_scope(token["name"]):
                self.tree.generate_implied_end_tags()
            if self.tree.open_elements[-1].name != token["name"]:
                self.parser.parse_error("end-tag-too-early", {"name": token["name"]})

            if self.tree.element_in_scope(token["name"]):
                element = self.tree.open_elements.pop()
                while element.name != token["name"]:
                    element = self.tree.open_elements.pop()
                self.tree.clear_active_formatting_elements()

        def end_tag_br(self, token):
            self.parser.parse_error("unexpected-end-tag-treated-as",
                                   {"original_name": "br", "new_name": "br element"})
            self.tree.reconstruct_active_formatting_elements()
            self.tree.insert_element(implied_tag_token("br", "StartTag"))
            self.tree.open_elements.pop()

        def end_tag_other(self, token):
            for node in self.tree.open_elements[::-1]:
                if node.name == token["name"]:
                    self.tree.generate_implied_end_tags(exclude=token["name"])
                    if self.tree.open_elements[-1].name != token["name"]:
                        self.parser.parse_error("unexpected-end-tag", {"name": token["name"]})
                    while self.tree.open_elements.pop() != node:
                        pass
                    break
                else:
                    if node.name_tuple in special_elements:
                        self.parser.parse_error("unexpected-end-tag", {"name": token["name"]})
                        break

        start_tag_handler = _utils.MethodDispatcher([
            ("html", Phase.start_tag_html),
            (("base", "basefont", "bgsound", "command", "link", "meta",
              "script", "style", "title"),
             start_tag_process_in_head),
            ("body", start_tag_body),
            ("frameset", start_tag_frameset),
            (("address", "article", "aside", "blockquote", "center", "details",
              "dir", "div", "dl", "fieldset", "figcaption", "figure",
              "footer", "header", "hgroup", "main", "menu", "nav", "ol", "p",
              "section", "summary", "ul"),
             start_tag_close_p),
            (heading_elements, start_tag_heading),
            (("pre", "listing"), start_tag_pre_listing),
            ("form", start_tag_form),
            (("li", "dd", "dt"), start_tag_list_item),
            ("plaintext", start_tag_plaintext),
            ("a", start_tag_a),
            (("b", "big", "code", "em", "font", "i", "s", "small", "strike",
              "strong", "tt", "u"), start_tag_formatting),
            ("nobr", start_tag_nobr),
            ("button", start_tag_button),
            (("applet", "marquee", "object"), start_tag_applet_marquee_object),
            ("xmp", start_tag_xmp),
            ("table", start_tag_table),
            (("area", "br", "embed", "img", "keygen", "wbr"),
             start_tag_void_formatting),
            (("param", "source", "track"), start_tag_param_source),
            ("input", start_tag_input),
            ("hr", start_tag_hr),
            ("image", start_tag_image),
            ("isindex", start_tag_is_index),
            ("textarea", start_tag_textarea),
            ("iframe", start_tag_i_frame),
            ("noscript", start_tag_noscript),
            (("noembed", "noframes"), start_tag_rawtext),
            ("select", start_tag_select),
            (("rp", "rt"), start_tag_rp_rt),
            (("option", "optgroup"), start_tag_opt),
            (("math"), start_tag_math),
            (("svg"), start_tag_svg),
            (("caption", "col", "colgroup", "frame", "head",
              "tbody", "td", "tfoot", "th", "thead",
              "tr"), start_tag_misplaced)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            ("body", end_tag_body),
            ("html", end_tag_html),
            (("address", "article", "aside", "blockquote", "button", "center",
              "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure",
              "footer", "header", "hgroup", "listing", "main", "menu", "nav", "ol", "pre",
              "section", "summary", "ul"), end_tag_block),
            ("form", end_tag_form),
            ("p", end_tag_p),
            (("dd", "dt", "li"), end_tag_list_item),
            (heading_elements, end_tag_heading),
            (("a", "b", "big", "code", "em", "font", "i", "nobr", "s", "small",
              "strike", "strong", "tt", "u"), end_tag_formatting),
            (("applet", "marquee", "object"), end_tag_applet_marquee_object),
            ("br", end_tag_br),
        ])
        end_tag_handler.default = end_tag_other

    class TextPhase(Phase):
        __slots__ = tuple()

        def process_characters(self, token):
            self.tree.insert_text(token["data"])

        def process_eof(self):
            self.parser.parse_error("expected-named-closing-tag-but-got-eof",
                                   {"name": self.tree.open_elements[-1].name})
            self.tree.open_elements.pop()
            self.parser.phase = self.parser.original_phase
            return True

        def start_tag_other(self, token):
            assert False, "Tried to process start tag %s in RCDATA/RAWTEXT mode" % token['name']

        def end_tag_script(self, token):
            node = self.tree.open_elements.pop()
            assert node.name == "script"
            self.parser.phase = self.parser.original_phase
            # The rest of this method is all stuff that only happens if
            # document.write works

        def end_tag_other(self, token):
            self.tree.open_elements.pop()
            self.parser.phase = self.parser.original_phase

        start_tag_handler = _utils.MethodDispatcher([])
        start_tag_handler.default = start_tag_other
        end_tag_handler = _utils.MethodDispatcher([
            ("script", end_tag_script)])
        end_tag_handler.default = end_tag_other

    class InTablePhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-table
        __slots__ = tuple()

        # helper methods
        def clear_stack_to_table_context(self):
            # "clear the stack back to a table context"
            while self.tree.open_elements[-1].name not in ("table", "html"):
                # self.parser.parse_error("unexpected-implied-end-tag-in-table",
                #  {"name":  self.tree.open_elements[-1].name})
                self.tree.open_elements.pop()
            # When the current node is <html> it's an inner_html case

        # processing methods
        def process_eof(self):
            if self.tree.open_elements[-1].name != "html":
                self.parser.parse_error("eof-in-table")
            else:
                assert self.parser.inner_html
            # Stop parsing

        def process_space_characters(self, token):
            original_phase = self.parser.phase
            self.parser.phase = self.parser.phases["in_table_text"]
            self.parser.phase.original_phase = original_phase
            self.parser.phase.process_space_characters(token)

        def process_characters(self, token):
            original_phase = self.parser.phase
            self.parser.phase = self.parser.phases["in_table_text"]
            self.parser.phase.original_phase = original_phase
            self.parser.phase.process_characters(token)

        def insert_text(self, token):
            # If we get here there must be at least one non-whitespace character
            # Do the table magic!
            self.tree.insert_from_table = True
            self.parser.phases["in_body"].process_characters(token)
            self.tree.insert_from_table = False

        def start_tag_caption(self, token):
            self.clear_stack_to_table_context()
            self.tree.active_formatting_elements.append(Marker)
            self.tree.insert_element(token)
            self.parser.phase = self.parser.phases["in_caption"]

        def start_tag_colgroup(self, token):
            self.clear_stack_to_table_context()
            self.tree.insert_element(token)
            self.parser.phase = self.parser.phases["in_column_group"]

        def start_tag_col(self, token):
            self.start_tag_colgroup(implied_tag_token("colgroup", "StartTag"))
            return token

        def start_tag_row_group(self, token):
            self.clear_stack_to_table_context()
            self.tree.insert_element(token)
            self.parser.phase = self.parser.phases["in_table_body"]

        def start_tag_imply_tbody(self, token):
            self.start_tag_row_group(implied_tag_token("tbody", "StartTag"))
            return token

        def start_tag_table(self, token):
            self.parser.parse_error("unexpected-start-tag-implies-end-tag",
                                   {"start_name": "table", "end_name": "table"})
            self.parser.phase.process_end_tag(implied_tag_token("table"))
            if not self.parser.inner_html:
                return token

        def start_tag_style_script(self, token):
            return self.parser.phases["in_head"].process_start_tag(token)

        def start_tag_input(self, token):
            if ("type" in token["data"] and
                    token["data"]["type"].translate(ascii_upper2_lower) == "hidden"):
                self.parser.parse_error("unexpected-hidden-input-in-table")
                self.tree.insert_element(token)
                # XXX associate with form
                self.tree.open_elements.pop()
            else:
                self.start_tag_other(token)

        def start_tag_form(self, token):
            self.parser.parse_error("unexpected-form-in-table")
            if self.tree.form_pointer is None:
                self.tree.insert_element(token)
                self.tree.form_pointer = self.tree.open_elements[-1]
                self.tree.open_elements.pop()

        def start_tag_other(self, token):
            self.parser.parse_error("unexpected-start-tag-implies-table-voodoo", {"name": token["name"]})
            # Do the table magic!
            self.tree.insert_from_table = True
            self.parser.phases["in_body"].process_start_tag(token)
            self.tree.insert_from_table = False

        def end_tag_table(self, token):
            if self.tree.element_in_scope("table", variant="table"):
                self.tree.generate_implied_end_tags()
                if self.tree.open_elements[-1].name != "table":
                    self.parser.parse_error("end-tag-too-early-named",
                                           {"got_name": "table",
                                            "expected_name": self.tree.open_elements[-1].name})
                while self.tree.open_elements[-1].name != "table":
                    self.tree.open_elements.pop()
                self.tree.open_elements.pop()
                self.parser.reset_insertion_mode()
            else:
                # inner_html case
                assert self.parser.inner_html
                self.parser.parse_error()

        def end_tag_ignore(self, token):
            self.parser.parse_error("unexpected-end-tag", {"name": token["name"]})

        def end_tag_other(self, token):
            self.parser.parse_error("unexpected-end-tag-implies-table-voodoo", {"name": token["name"]})
            # Do the table magic!
            self.tree.insert_from_table = True
            self.parser.phases["in_body"].process_end_tag(token)
            self.tree.insert_from_table = False

        start_tag_handler = _utils.MethodDispatcher([
            ("html", Phase.start_tag_html),
            ("caption", start_tag_caption),
            ("colgroup", start_tag_colgroup),
            ("col", start_tag_col),
            (("tbody", "tfoot", "thead"), start_tag_row_group),
            (("td", "th", "tr"), start_tag_imply_tbody),
            ("table", start_tag_table),
            (("style", "script"), start_tag_style_script),
            ("input", start_tag_input),
            ("form", start_tag_form)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            ("table", end_tag_table),
            (("body", "caption", "col", "colgroup", "html", "tbody", "td",
              "tfoot", "th", "thead", "tr"), end_tag_ignore)
        ])
        end_tag_handler.default = end_tag_other

    class InTableTextPhase(Phase):
        __slots__ = ("original_phase", "character_tokens")

        def __init__(self, *args, **kwargs):
            super(InTableTextPhase, self).__init__(*args, **kwargs)
            self.original_phase = None
            self.character_tokens = []

        def flush_characters(self):
            data = "".join([item["data"] for item in self.character_tokens])
            if any([item not in space_characters for item in data]):
                token = {"type": token_types["Characters"], "data": data}
                self.parser.phases["in_table"].insert_text(token)
            elif data:
                self.tree.insert_text(data)
            self.character_tokens = []

        def process_comment(self, token):
            self.flush_characters()
            self.parser.phase = self.original_phase
            return token

        def process_eof(self):
            self.flush_characters()
            self.parser.phase = self.original_phase
            return True

        def process_characters(self, token):
            if token["data"] == "\u0000":
                return
            self.character_tokens.append(token)

        def process_space_characters(self, token):
            # pretty sure we should never reach here
            self.character_tokens.append(token)
    #        assert False

        def process_start_tag(self, token):
            self.flush_characters()
            self.parser.phase = self.original_phase
            return token

        def process_end_tag(self, token):
            self.flush_characters()
            self.parser.phase = self.original_phase
            return token

    class InCaptionPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-caption
        __slots__ = tuple()

        def ignore_end_tag_caption(self):
            return not self.tree.element_in_scope("caption", variant="table")

        def process_eof(self):
            self.parser.phases["in_body"].process_eof()

        def process_characters(self, token):
            return self.parser.phases["in_body"].process_characters(token)

        def start_tag_table_element(self, token):
            self.parser.parse_error()
            # XXX Have to duplicate logic here to find out if the tag is ignored
            ignore_end_tag = self.ignore_end_tag_caption()
            self.parser.phase.process_end_tag(implied_tag_token("caption"))
            if not ignore_end_tag:
                return token

        def start_tag_other(self, token):
            return self.parser.phases["in_body"].process_start_tag(token)

        def end_tag_caption(self, token):
            if not self.ignore_end_tag_caption():
                # AT this code is quite similar to end_tag_table in "InTable"
                self.tree.generate_implied_end_tags()
                if self.tree.open_elements[-1].name != "caption":
                    self.parser.parse_error("expected-one-end-tag-but-got-another",
                                           {"got_name": "caption",
                                            "expected_name": self.tree.open_elements[-1].name})
                while self.tree.open_elements[-1].name != "caption":
                    self.tree.open_elements.pop()
                self.tree.open_elements.pop()
                self.tree.clear_active_formatting_elements()
                self.parser.phase = self.parser.phases["in_table"]
            else:
                # inner_html case
                assert self.parser.inner_html
                self.parser.parse_error()

        def end_tag_table(self, token):
            self.parser.parse_error()
            ignore_end_tag = self.ignore_end_tag_caption()
            self.parser.phase.process_end_tag(implied_tag_token("caption"))
            if not ignore_end_tag:
                return token

        def end_tag_ignore(self, token):
            self.parser.parse_error("unexpected-end-tag", {"name": token["name"]})

        def end_tag_other(self, token):
            return self.parser.phases["in_body"].process_end_tag(token)

        start_tag_handler = _utils.MethodDispatcher([
            ("html", Phase.start_tag_html),
            (("caption", "col", "colgroup", "tbody", "td", "tfoot", "th",
              "thead", "tr"), start_tag_table_element)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            ("caption", end_tag_caption),
            ("table", end_tag_table),
            (("body", "col", "colgroup", "html", "tbody", "td", "tfoot", "th",
              "thead", "tr"), end_tag_ignore)
        ])
        end_tag_handler.default = end_tag_other

    class InColumnGroupPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-column
        __slots__ = tuple()

        def ignore_end_tag_colgroup(self):
            return self.tree.open_elements[-1].name == "html"

        def process_eof(self):
            if self.tree.open_elements[-1].name == "html":
                assert self.parser.inner_html
                return
            else:
                ignore_end_tag = self.ignore_end_tag_colgroup()
                self.end_tag_colgroup(implied_tag_token("colgroup"))
                if not ignore_end_tag:
                    return True

        def process_characters(self, token):
            ignore_end_tag = self.ignore_end_tag_colgroup()
            self.end_tag_colgroup(implied_tag_token("colgroup"))
            if not ignore_end_tag:
                return token

        def start_tag_col(self, token):
            self.tree.insert_element(token)
            self.tree.open_elements.pop()
            token["self_closing_acknowledged"] = True

        def start_tag_other(self, token):
            ignore_end_tag = self.ignore_end_tag_colgroup()
            self.end_tag_colgroup(implied_tag_token("colgroup"))
            if not ignore_end_tag:
                return token

        def end_tag_colgroup(self, token):
            if self.ignore_end_tag_colgroup():
                # inner_html case
                assert self.parser.inner_html
                self.parser.parse_error()
            else:
                self.tree.open_elements.pop()
                self.parser.phase = self.parser.phases["in_table"]

        def end_tag_col(self, token):
            self.parser.parse_error("no-end-tag", {"name": "col"})

        def end_tag_other(self, token):
            ignore_end_tag = self.ignore_end_tag_colgroup()
            self.end_tag_colgroup(implied_tag_token("colgroup"))
            if not ignore_end_tag:
                return token

        start_tag_handler = _utils.MethodDispatcher([
            ("html", Phase.start_tag_html),
            ("col", start_tag_col)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            ("colgroup", end_tag_colgroup),
            ("col", end_tag_col)
        ])
        end_tag_handler.default = end_tag_other

    class InTableBodyPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-table0
        __slots__ = tuple()

        # helper methods
        def clear_stack_to_table_body_context(self):
            while self.tree.open_elements[-1].name not in ("tbody", "tfoot",
                                                          "thead", "html"):
                # self.parser.parse_error("unexpected-implied-end-tag-in-table",
                #  {"name": self.tree.open_elements[-1].name})
                self.tree.open_elements.pop()
            if self.tree.open_elements[-1].name == "html":
                assert self.parser.inner_html

        # the rest
        def process_eof(self):
            self.parser.phases["in_table"].process_eof()

        def process_space_characters(self, token):
            return self.parser.phases["in_table"].process_space_characters(token)

        def process_characters(self, token):
            return self.parser.phases["in_table"].process_characters(token)

        def start_tag_tr(self, token):
            self.clear_stack_to_table_body_context()
            self.tree.insert_element(token)
            self.parser.phase = self.parser.phases["in_row"]

        def start_tag_table_cell(self, token):
            self.parser.parse_error("unexpected-cell-in-table-body",
                                   {"name": token["name"]})
            self.start_tag_tr(implied_tag_token("tr", "StartTag"))
            return token

        def start_tag_table_other(self, token):
            # XXX AT Any ideas on how to share this with end_tag_table?
            if (self.tree.element_in_scope("tbody", variant="table") or
                self.tree.element_in_scope("thead", variant="table") or
                    self.tree.element_in_scope("tfoot", variant="table")):
                self.clear_stack_to_table_body_context()
                self.end_tag_table_row_group(
                    implied_tag_token(self.tree.open_elements[-1].name))
                return token
            else:
                # inner_html case
                assert self.parser.inner_html
                self.parser.parse_error()

        def start_tag_other(self, token):
            return self.parser.phases["in_table"].process_start_tag(token)

        def end_tag_table_row_group(self, token):
            if self.tree.element_in_scope(token["name"], variant="table"):
                self.clear_stack_to_table_body_context()
                self.tree.open_elements.pop()
                self.parser.phase = self.parser.phases["in_table"]
            else:
                self.parser.parse_error("unexpected-end-tag-in-table-body",
                                       {"name": token["name"]})

        def end_tag_table(self, token):
            if (self.tree.element_in_scope("tbody", variant="table") or
                self.tree.element_in_scope("thead", variant="table") or
                    self.tree.element_in_scope("tfoot", variant="table")):
                self.clear_stack_to_table_body_context()
                self.end_tag_table_row_group(
                    implied_tag_token(self.tree.open_elements[-1].name))
                return token
            else:
                # inner_html case
                assert self.parser.inner_html
                self.parser.parse_error()

        def end_tag_ignore(self, token):
            self.parser.parse_error("unexpected-end-tag-in-table-body",
                                   {"name": token["name"]})

        def end_tag_other(self, token):
            return self.parser.phases["in_table"].process_end_tag(token)

        start_tag_handler = _utils.MethodDispatcher([
            ("html", Phase.start_tag_html),
            ("tr", start_tag_tr),
            (("td", "th"), start_tag_table_cell),
            (("caption", "col", "colgroup", "tbody", "tfoot", "thead"),
             start_tag_table_other)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            (("tbody", "tfoot", "thead"), end_tag_table_row_group),
            ("table", end_tag_table),
            (("body", "caption", "col", "colgroup", "html", "td", "th",
              "tr"), end_tag_ignore)
        ])
        end_tag_handler.default = end_tag_other

    class InRowPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-row
        __slots__ = tuple()

        # helper methods (XXX unify this with other table helper methods)
        def clear_stack_to_table_row_context(self):
            while self.tree.open_elements[-1].name not in ("tr", "html"):
                self.parser.parse_error("unexpected-implied-end-tag-in-table-row",
                                       {"name": self.tree.open_elements[-1].name})
                self.tree.open_elements.pop()

        def ignore_end_tag_tr(self):
            return not self.tree.element_in_scope("tr", variant="table")

        # the rest
        def process_eof(self):
            self.parser.phases["in_table"].process_eof()

        def process_space_characters(self, token):
            return self.parser.phases["in_table"].process_space_characters(token)

        def process_characters(self, token):
            return self.parser.phases["in_table"].process_characters(token)

        def start_tag_table_cell(self, token):
            self.clear_stack_to_table_row_context()
            self.tree.insert_element(token)
            self.parser.phase = self.parser.phases["in_cell"]
            self.tree.active_formatting_elements.append(Marker)

        def start_tag_table_other(self, token):
            ignore_end_tag = self.ignore_end_tag_tr()
            self.end_tag_tr(implied_tag_token("tr"))
            # XXX how are we sure it's always ignored in the inner_html case?
            if not ignore_end_tag:
                return token

        def start_tag_other(self, token):
            return self.parser.phases["in_table"].process_start_tag(token)

        def end_tag_tr(self, token):
            if not self.ignore_end_tag_tr():
                self.clear_stack_to_table_row_context()
                self.tree.open_elements.pop()
                self.parser.phase = self.parser.phases["in_table_body"]
            else:
                # inner_html case
                assert self.parser.inner_html
                self.parser.parse_error()

        def end_tag_table(self, token):
            ignore_end_tag = self.ignore_end_tag_tr()
            self.end_tag_tr(implied_tag_token("tr"))
            # Reprocess the current tag if the tr end tag was not ignored
            # XXX how are we sure it's always ignored in the inner_html case?
            if not ignore_end_tag:
                return token

        def end_tag_table_row_group(self, token):
            if self.tree.element_in_scope(token["name"], variant="table"):
                self.end_tag_tr(implied_tag_token("tr"))
                return token
            else:
                self.parser.parse_error()

        def end_tag_ignore(self, token):
            self.parser.parse_error("unexpected-end-tag-in-table-row",
                                   {"name": token["name"]})

        def end_tag_other(self, token):
            return self.parser.phases["in_table"].process_end_tag(token)

        start_tag_handler = _utils.MethodDispatcher([
            ("html", Phase.start_tag_html),
            (("td", "th"), start_tag_table_cell),
            (("caption", "col", "colgroup", "tbody", "tfoot", "thead",
              "tr"), start_tag_table_other)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            ("tr", end_tag_tr),
            ("table", end_tag_table),
            (("tbody", "tfoot", "thead"), end_tag_table_row_group),
            (("body", "caption", "col", "colgroup", "html", "td", "th"),
             end_tag_ignore)
        ])
        end_tag_handler.default = end_tag_other

    class InCellPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-cell
        __slots__ = tuple()

        # helper
        def close_cell(self):
            if self.tree.element_in_scope("td", variant="table"):
                self.end_tag_table_cell(implied_tag_token("td"))
            elif self.tree.element_in_scope("th", variant="table"):
                self.end_tag_table_cell(implied_tag_token("th"))

        # the rest
        def process_eof(self):
            self.parser.phases["in_body"].process_eof()

        def process_characters(self, token):
            return self.parser.phases["in_body"].process_characters(token)

        def start_tag_table_other(self, token):
            if (self.tree.element_in_scope("td", variant="table") or
                    self.tree.element_in_scope("th", variant="table")):
                self.close_cell()
                return token
            else:
                # inner_html case
                assert self.parser.inner_html
                self.parser.parse_error()

        def start_tag_other(self, token):
            return self.parser.phases["in_body"].process_start_tag(token)

        def end_tag_table_cell(self, token):
            if self.tree.element_in_scope(token["name"], variant="table"):
                self.tree.generate_implied_end_tags(token["name"])
                if self.tree.open_elements[-1].name != token["name"]:
                    self.parser.parse_error("unexpected-cell-end-tag",
                                           {"name": token["name"]})
                    while True:
                        node = self.tree.open_elements.pop()
                        if node.name == token["name"]:
                            break
                else:
                    self.tree.open_elements.pop()
                self.tree.clear_active_formatting_elements()
                self.parser.phase = self.parser.phases["in_row"]
            else:
                self.parser.parse_error("unexpected-end-tag", {"name": token["name"]})

        def end_tag_ignore(self, token):
            self.parser.parse_error("unexpected-end-tag", {"name": token["name"]})

        def end_tag_imply(self, token):
            if self.tree.element_in_scope(token["name"], variant="table"):
                self.close_cell()
                return token
            else:
                # sometimes inner_html case
                self.parser.parse_error()

        def end_tag_other(self, token):
            return self.parser.phases["in_body"].process_end_tag(token)

        start_tag_handler = _utils.MethodDispatcher([
            ("html", Phase.start_tag_html),
            (("caption", "col", "colgroup", "tbody", "td", "tfoot", "th",
              "thead", "tr"), start_tag_table_other)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            (("td", "th"), end_tag_table_cell),
            (("body", "caption", "col", "colgroup", "html"), end_tag_ignore),
            (("table", "tbody", "tfoot", "thead", "tr"), end_tag_imply)
        ])
        end_tag_handler.default = end_tag_other

    class InSelectPhase(Phase):
        __slots__ = tuple()

        # http://www.whatwg.org/specs/web-apps/current-work/#in-select
        def process_eof(self):
            if self.tree.open_elements[-1].name != "html":
                self.parser.parse_error("eof-in-select")
            else:
                assert self.parser.inner_html

        def process_characters(self, token):
            if token["data"] == "\u0000":
                return
            self.tree.insert_text(token["data"])

        def start_tag_option(self, token):
            # We need to imply </option> if <option> is the current node.
            if self.tree.open_elements[-1].name == "option":
                self.tree.open_elements.pop()
            self.tree.insert_element(token)

        def start_tag_optgroup(self, token):
            if self.tree.open_elements[-1].name == "option":
                self.tree.open_elements.pop()
            if self.tree.open_elements[-1].name == "optgroup":
                self.tree.open_elements.pop()
            self.tree.insert_element(token)

        def start_tag_select(self, token):
            self.parser.parse_error("unexpected-select-in-select")
            self.end_tag_select(implied_tag_token("select"))

        def start_tag_input(self, token):
            self.parser.parse_error("unexpected-input-in-select")
            if self.tree.element_in_scope("select", variant="select"):
                self.end_tag_select(implied_tag_token("select"))
                return token
            else:
                assert self.parser.inner_html

        def start_tag_script(self, token):
            return self.parser.phases["in_head"].process_start_tag(token)

        def start_tag_other(self, token):
            self.parser.parse_error("unexpected-start-tag-in-select",
                                   {"name": token["name"]})

        def end_tag_option(self, token):
            if self.tree.open_elements[-1].name == "option":
                self.tree.open_elements.pop()
            else:
                self.parser.parse_error("unexpected-end-tag-in-select",
                                       {"name": "option"})

        def end_tag_optgroup(self, token):
            # </optgroup> implicitly closes <option>
            if (self.tree.open_elements[-1].name == "option" and
                    self.tree.open_elements[-2].name == "optgroup"):
                self.tree.open_elements.pop()
            # It also closes </optgroup>
            if self.tree.open_elements[-1].name == "optgroup":
                self.tree.open_elements.pop()
            # But nothing else
            else:
                self.parser.parse_error("unexpected-end-tag-in-select",
                                       {"name": "optgroup"})

        def end_tag_select(self, token):
            if self.tree.element_in_scope("select", variant="select"):
                node = self.tree.open_elements.pop()
                while node.name != "select":
                    node = self.tree.open_elements.pop()
                self.parser.reset_insertion_mode()
            else:
                # inner_html case
                assert self.parser.inner_html
                self.parser.parse_error()

        def end_tag_other(self, token):
            self.parser.parse_error("unexpected-end-tag-in-select",
                                   {"name": token["name"]})

        start_tag_handler = _utils.MethodDispatcher([
            ("html", Phase.start_tag_html),
            ("option", start_tag_option),
            ("optgroup", start_tag_optgroup),
            ("select", start_tag_select),
            (("input", "keygen", "textarea"), start_tag_input),
            ("script", start_tag_script)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            ("option", end_tag_option),
            ("optgroup", end_tag_optgroup),
            ("select", end_tag_select)
        ])
        end_tag_handler.default = end_tag_other

    class InSelectInTablePhase(Phase):
        __slots__ = tuple()

        def process_eof(self):
            self.parser.phases["in_select"].process_eof()

        def process_characters(self, token):
            return self.parser.phases["in_select"].process_characters(token)

        def start_tag_table(self, token):
            self.parser.parse_error("unexpected-table-element-start-tag-in-select-in-table", {"name": token["name"]})
            self.end_tag_other(implied_tag_token("select"))
            return token

        def start_tag_other(self, token):
            return self.parser.phases["in_select"].process_start_tag(token)

        def end_tag_table(self, token):
            self.parser.parse_error("unexpected-table-element-end-tag-in-select-in-table", {"name": token["name"]})
            if self.tree.element_in_scope(token["name"], variant="table"):
                self.end_tag_other(implied_tag_token("select"))
                return token

        def end_tag_other(self, token):
            return self.parser.phases["in_select"].process_end_tag(token)

        start_tag_handler = _utils.MethodDispatcher([
            (("caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th"),
             start_tag_table)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            (("caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th"),
             end_tag_table)
        ])
        end_tag_handler.default = end_tag_other

    class InForeignContentPhase(Phase):
        __slots__ = tuple()

        breakout_elements = frozenset(["b", "big", "blockquote", "body", "br",
                                      "center", "code", "dd", "div", "dl", "dt",
                                      "em", "embed", "h1", "h2", "h3",
                                      "h4", "h5", "h6", "head", "hr", "i", "img",
                                      "li", "listing", "menu", "meta", "nobr",
                                      "ol", "p", "pre", "ruby", "s", "small",
                                      "span", "strong", "strike", "sub", "sup",
                                      "table", "tt", "u", "ul", "var"])

        def adjust_svg_tag_names(self, token):
            replacements = {"altglyph": "alt_glyph",
                            "altglyphdef": "alt_glyph_def",
                            "altglyphitem": "alt_glyph_item",
                            "animatecolor": "animate_color",
                            "animatemotion": "animate_motion",
                            "animatetransform": "animate_transform",
                            "clippath": "clip_path",
                            "feblend": "fe_blend",
                            "fecolormatrix": "fe_color_matrix",
                            "fecomponenttransfer": "fe_component_transfer",
                            "fecomposite": "fe_composite",
                            "feconvolvematrix": "fe_convolve_matrix",
                            "fediffuselighting": "fe_diffuse_lighting",
                            "fedisplacementmap": "fe_displacement_map",
                            "fedistantlight": "fe_distant_light",
                            "feflood": "fe_flood",
                            "fefunca": "fe_func_a",
                            "fefuncb": "fe_func_b",
                            "fefuncg": "fe_func_g",
                            "fefuncr": "fe_func_r",
                            "fegaussianblur": "fe_gaussian_blur",
                            "feimage": "fe_image",
                            "femerge": "fe_merge",
                            "femergenode": "fe_merge_node",
                            "femorphology": "fe_morphology",
                            "feoffset": "fe_offset",
                            "fepointlight": "fe_point_light",
                            "fespecularlighting": "fe_specular_lighting",
                            "fespotlight": "fe_spot_light",
                            "fetile": "fe_tile",
                            "feturbulence": "fe_turbulence",
                            "foreignobject": "foreign_object",
                            "glyphref": "glyph_ref",
                            "lineargradient": "linear_gradient",
                            "radialgradient": "radial_gradient",
                            "textpath": "text_path"}

            if token["name"] in replacements:
                token["name"] = replacements[token["name"]]

        def process_characters(self, token):
            if token["data"] == "\u0000":
                token["data"] = "\u_fffd"
            elif (self.parser.frameset_ok and
                  any(char not in space_characters for char in token["data"])):
                self.parser.frameset_ok = False
            Phase.process_characters(self, token)

        def process_start_tag(self, token):
            current_node = self.tree.open_elements[-1]
            if (token["name"] in self.breakout_elements or
                (token["name"] == "font" and
                 set(token["data"].keys()) & {"color", "face", "size"})):
                self.parser.parse_error("unexpected-html-element-in-foreign-content",
                                       {"name": token["name"]})
                while (self.tree.open_elements[-1].namespace !=
                       self.tree.default_namespace and
                       not self.parser.is_html_integration_point(self.tree.open_elements[-1]) and
                       not self.parser.is_math_ml_text_integration_point(self.tree.open_elements[-1])):
                    self.tree.open_elements.pop()
                return token

            else:
                if current_node.namespace == namespaces["mathml"]:
                    self.parser.adjust_math_ml_attributes(token)
                elif current_node.namespace == namespaces["svg"]:
                    self.adjust_svg_tag_names(token)
                    self.parser.adjust_svg_attributes(token)
                self.parser.adjust_foreign_attributes(token)
                token["namespace"] = current_node.namespace
                self.tree.insert_element(token)
                if token["self_closing"]:
                    self.tree.open_elements.pop()
                    token["self_closing_acknowledged"] = True

        def process_end_tag(self, token):
            node_index = len(self.tree.open_elements) - 1
            node = self.tree.open_elements[-1]
            if node.name.translate(ascii_upper2_lower) != token["name"]:
                self.parser.parse_error("unexpected-end-tag", {"name": token["name"]})

            while True:
                if node.name.translate(ascii_upper2_lower) == token["name"]:
                    # XXX this isn't in the spec but it seems necessary
                    if self.parser.phase == self.parser.phases["in_table_text"]:
                        self.parser.phase.flush_characters()
                        self.parser.phase = self.parser.phase.original_phase
                    while self.tree.open_elements.pop() != node:
                        assert self.tree.open_elements
                    new_token = None
                    break
                node_index -= 1

                node = self.tree.open_elements[node_index]
                if node.namespace != self.tree.default_namespace:
                    continue
                else:
                    new_token = self.parser.phase.process_end_tag(token)
                    break
            return new_token

    class AfterBodyPhase(Phase):
        __slots__ = tuple()

        def process_eof(self):
            # Stop parsing
            pass

        def process_comment(self, token):
            # This is needed because data is to be appended to the <html> element
            # here and not to whatever is currently open.
            self.tree.insert_comment(token, self.tree.open_elements[0])

        def process_characters(self, token):
            self.parser.parse_error("unexpected-char-after-body")
            self.parser.phase = self.parser.phases["in_body"]
            return token

        def start_tag_html(self, token):
            return self.parser.phases["in_body"].process_start_tag(token)

        def start_tag_other(self, token):
            self.parser.parse_error("unexpected-start-tag-after-body",
                                   {"name": token["name"]})
            self.parser.phase = self.parser.phases["in_body"]
            return token

        def end_tag_html(self, name):
            if self.parser.inner_html:
                self.parser.parse_error("unexpected-end-tag-after-body-innerhtml")
            else:
                self.parser.phase = self.parser.phases["after_after_body"]

        def end_tag_other(self, token):
            self.parser.parse_error("unexpected-end-tag-after-body",
                                   {"name": token["name"]})
            self.parser.phase = self.parser.phases["in_body"]
            return token

        start_tag_handler = _utils.MethodDispatcher([
            ("html", start_tag_html)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([("html", end_tag_html)])
        end_tag_handler.default = end_tag_other

    class InFramesetPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-frameset
        __slots__ = tuple()

        def process_eof(self):
            if self.tree.open_elements[-1].name != "html":
                self.parser.parse_error("eof-in-frameset")
            else:
                assert self.parser.inner_html

        def process_characters(self, token):
            self.parser.parse_error("unexpected-char-in-frameset")

        def start_tag_frameset(self, token):
            self.tree.insert_element(token)

        def start_tag_frame(self, token):
            self.tree.insert_element(token)
            self.tree.open_elements.pop()

        def start_tag_noframes(self, token):
            return self.parser.phases["in_body"].process_start_tag(token)

        def start_tag_other(self, token):
            self.parser.parse_error("unexpected-start-tag-in-frameset",
                                   {"name": token["name"]})

        def end_tag_frameset(self, token):
            if self.tree.open_elements[-1].name == "html":
                # inner_html case
                self.parser.parse_error("unexpected-frameset-in-frameset-innerhtml")
            else:
                self.tree.open_elements.pop()
            if (not self.parser.inner_html and
                    self.tree.open_elements[-1].name != "frameset"):
                # If we're not in inner_html mode and the current node is not a
                # "frameset" element (anymore) then switch.
                self.parser.phase = self.parser.phases["after_frameset"]

        def end_tag_other(self, token):
            self.parser.parse_error("unexpected-end-tag-in-frameset",
                                   {"name": token["name"]})

        start_tag_handler = _utils.MethodDispatcher([
            ("html", Phase.start_tag_html),
            ("frameset", start_tag_frameset),
            ("frame", start_tag_frame),
            ("noframes", start_tag_noframes)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            ("frameset", end_tag_frameset)
        ])
        end_tag_handler.default = end_tag_other

    class AfterFramesetPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#after3
        __slots__ = tuple()

        def process_eof(self):
            # Stop parsing
            pass

        def process_characters(self, token):
            self.parser.parse_error("unexpected-char-after-frameset")

        def start_tag_noframes(self, token):
            return self.parser.phases["in_head"].process_start_tag(token)

        def start_tag_other(self, token):
            self.parser.parse_error("unexpected-start-tag-after-frameset",
                                   {"name": token["name"]})

        def end_tag_html(self, token):
            self.parser.phase = self.parser.phases["after_after_frameset"]

        def end_tag_other(self, token):
            self.parser.parse_error("unexpected-end-tag-after-frameset",
                                   {"name": token["name"]})

        start_tag_handler = _utils.MethodDispatcher([
            ("html", Phase.start_tag_html),
            ("noframes", start_tag_noframes)
        ])
        start_tag_handler.default = start_tag_other

        end_tag_handler = _utils.MethodDispatcher([
            ("html", end_tag_html)
        ])
        end_tag_handler.default = end_tag_other

    class AfterAfterBodyPhase(Phase):
        __slots__ = tuple()

        def process_eof(self):
            pass

        def process_comment(self, token):
            self.tree.insert_comment(token, self.tree.document)

        def process_space_characters(self, token):
            return self.parser.phases["in_body"].process_space_characters(token)

        def process_characters(self, token):
            self.parser.parse_error("expected-eof-but-got-char")
            self.parser.phase = self.parser.phases["in_body"]
            return token

        def start_tag_html(self, token):
            return self.parser.phases["in_body"].process_start_tag(token)

        def start_tag_other(self, token):
            self.parser.parse_error("expected-eof-but-got-start-tag",
                                   {"name": token["name"]})
            self.parser.phase = self.parser.phases["in_body"]
            return token

        def process_end_tag(self, token):
            self.parser.parse_error("expected-eof-but-got-end-tag",
                                   {"name": token["name"]})
            self.parser.phase = self.parser.phases["in_body"]
            return token

        start_tag_handler = _utils.MethodDispatcher([
            ("html", start_tag_html)
        ])
        start_tag_handler.default = start_tag_other

    class AfterAfterFramesetPhase(Phase):
        __slots__ = tuple()

        def process_eof(self):
            pass

        def process_comment(self, token):
            self.tree.insert_comment(token, self.tree.document)

        def process_space_characters(self, token):
            return self.parser.phases["in_body"].process_space_characters(token)

        def process_characters(self, token):
            self.parser.parse_error("expected-eof-but-got-char")

        def start_tag_html(self, token):
            return self.parser.phases["in_body"].process_start_tag(token)

        def start_tag_no_frames(self, token):
            return self.parser.phases["in_head"].process_start_tag(token)

        def start_tag_other(self, token):
            self.parser.parse_error("expected-eof-but-got-start-tag",
                                   {"name": token["name"]})

        def process_end_tag(self, token):
            self.parser.parse_error("expected-eof-but-got-end-tag",
                                   {"name": token["name"]})

        start_tag_handler = _utils.MethodDispatcher([
            ("html", start_tag_html),
            ("noframes", start_tag_no_frames)
        ])
        start_tag_handler.default = start_tag_other

    # pylint:enable=unused-argument

    return {
        "initial": InitialPhase,
        "before_html": BeforeHtmlPhase,
        "before_head": BeforeHeadPhase,
        "in_head": InHeadPhase,
        "in_head_noscript": InHeadNoscriptPhase,
        "after_head": AfterHeadPhase,
        "in_body": InBodyPhase,
        "text": TextPhase,
        "in_table": InTablePhase,
        "in_table_text": InTableTextPhase,
        "in_caption": InCaptionPhase,
        "in_column_group": InColumnGroupPhase,
        "in_table_body": InTableBodyPhase,
        "in_row": InRowPhase,
        "in_cell": InCellPhase,
        "in_select": InSelectPhase,
        "in_select_in_table": InSelectInTablePhase,
        "in_foreign_content": InForeignContentPhase,
        "after_body": AfterBodyPhase,
        "in_frameset": InFramesetPhase,
        "after_frameset": AfterFramesetPhase,
        "after_after_body": AfterAfterBodyPhase,
        "after_after_frameset": AfterAfterFramesetPhase,
        # XXX after after frameset
    }


def adjust_attributes(token, replacements):
    needs_adjustment = viewkeys(token['data']) & viewkeys(replacements)
    if needs_adjustment:
        token['data'] = type(token['data'])((replacements.get(k, k), v)
                                            for k, v in token['data'].items())


def implied_tag_token(name, type="EndTag", attributes=None,
                    self_closing=False):
    if attributes is None:
        attributes = {}
    return {"type": token_types[type], "name": name, "data": attributes,
            "self_closing": self_closing}


class ParseError(Exception):
    """Error in parsed document"""
    pass
