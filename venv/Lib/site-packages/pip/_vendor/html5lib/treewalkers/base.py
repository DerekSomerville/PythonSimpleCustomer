from __future__ import absolute_import, division, unicode_literals

from xml.dom import Node
from ..constants import namespaces, void_elements, space_characters

__all__ = ["DOCUMENT", "DOCTYPE", "TEXT", "ELEMENT", "COMMENT", "ENTITY", "UNKNOWN",
           "TreeWalker", "NonRecursiveTreeWalker"]

DOCUMENT = Node.DOCUMENT_NODE
DOCTYPE = Node.DOCUMENT_TYPE_NODE
TEXT = Node.TEXT_NODE
ELEMENT = Node.ELEMENT_NODE
COMMENT = Node.COMMENT_NODE
ENTITY = Node.ENTITY_NODE
UNKNOWN = "<#UNKNOWN#>"

space_characters = "".join(space_characters)


class TreeWalker(object):
    """Walks a tree yielding tokens

    Tokens are dicts that all have a ``type`` field specifying the type of the
    token.

    """
    def __init__(self, tree):
        """Creates a TreeWalker

        :arg tree: the tree to walk

        """
        self.tree = tree

    def __iter__(self):
        raise NotImplementedError

    def error(self, msg):
        """Generates an error token with the given message

        :arg msg: the error message

        :returns: SerializeError token

        """
        return {"type": "SerializeError", "data": msg}

    def empty_tag(self, namespace, name, attrs, has_children=False):
        """Generates an EmptyTag token

        :arg namespace: the namespace of the token--can be ``None``

        :arg name: the name of the element

        :arg attrs: the attributes of the element as a dict

        :arg has_children: whether or not to yield a SerializationError because
            this tag shouldn't have children

        :returns: EmptyTag token

        """
        yield {"type": "EmptyTag", "name": name,
               "namespace": namespace,
               "data": attrs}
        if has_children:
            yield self.error("Void element has children")

    def start_tag(self, namespace, name, attrs):
        """Generates a StartTag token

        :arg namespace: the namespace of the token--can be ``None``

        :arg name: the name of the element

        :arg attrs: the attributes of the element as a dict

        :returns: StartTag token

        """
        return {"type": "StartTag",
                "name": name,
                "namespace": namespace,
                "data": attrs}

    def end_tag(self, namespace, name):
        """Generates an EndTag token

        :arg namespace: the namespace of the token--can be ``None``

        :arg name: the name of the element

        :returns: EndTag token

        """
        return {"type": "EndTag",
                "name": name,
                "namespace": namespace}

    def text(self, data):
        """Generates SpaceCharacters and Characters tokens

        Depending on what's in the data, this generates one or more
        ``SpaceCharacters`` and ``Characters`` tokens.

        For example:

            >>> from html5lib.treewalkers.base import TreeWalker
            >>> # Give it an empty tree just so it instantiates
            >>> walker = TreeWalker([])
            >>> list(walker.text(''))
            []
            >>> list(walker.text('  '))
            [{u'data': '  ', u'type': u'SpaceCharacters'}]
            >>> list(walker.text(' abc '))  # doctest: +NORMALIZE_WHITESPACE
            [{u'data': ' ', u'type': u'SpaceCharacters'},
            {u'data': u'abc', u'type': u'Characters'},
            {u'data': u' ', u'type': u'SpaceCharacters'}]

        :arg data: the text data

        :returns: one or more ``SpaceCharacters`` and ``Characters`` tokens

        """
        data = data
        middle = data.lstrip(space_characters)
        left = data[:len(data) - len(middle)]
        if left:
            yield {"type": "SpaceCharacters", "data": left}
        data = middle
        middle = data.rstrip(space_characters)
        right = data[len(middle):]
        if middle:
            yield {"type": "Characters", "data": middle}
        if right:
            yield {"type": "SpaceCharacters", "data": right}

    def comment(self, data):
        """Generates a Comment token

        :arg data: the comment

        :returns: Comment token

        """
        return {"type": "Comment", "data": data}

    def doctype(self, name, public_id=None, system_id=None):
        """Generates a Doctype token

        :arg name:

        :arg public_id:

        :arg system_id:

        :returns: the Doctype token

        """
        return {"type": "Doctype",
                "name": name,
                "public_id": public_id,
                "system_id": system_id}

    def entity(self, name):
        """Generates an Entity token

        :arg name: the entity name

        :returns: an Entity token

        """
        return {"type": "Entity", "name": name}

    def unknown(self, node_type):
        """Handles unknown node types"""
        return self.error("Unknown node type: " + node_type)


class NonRecursiveTreeWalker(TreeWalker):
    def get_node_details(self, node):
        raise NotImplementedError

    def get_first_child(self, node):
        raise NotImplementedError

    def get_next_sibling(self, node):
        raise NotImplementedError

    def get_parent_node(self, node):
        raise NotImplementedError

    def __iter__(self):
        current_node = self.tree
        while current_node is not None:
            details = self.get_node_details(current_node)
            type, details = details[0], details[1:]
            has_children = False

            if type == DOCTYPE:
                yield self.doctype(*details)

            elif type == TEXT:
                for token in self.text(*details):
                    yield token

            elif type == ELEMENT:
                namespace, name, attributes, has_children = details
                if (not namespace or namespace == namespaces["html"]) and name in void_elements:
                    for token in self.empty_tag(namespace, name, attributes,
                                               has_children):
                        yield token
                    has_children = False
                else:
                    yield self.start_tag(namespace, name, attributes)

            elif type == COMMENT:
                yield self.comment(details[0])

            elif type == ENTITY:
                yield self.entity(details[0])

            elif type == DOCUMENT:
                has_children = True

            else:
                yield self.unknown(details[0])

            if has_children:
                first_child = self.get_first_child(current_node)
            else:
                first_child = None

            if first_child is not None:
                current_node = first_child
            else:
                while current_node is not None:
                    details = self.get_node_details(current_node)
                    type, details = details[0], details[1:]
                    if type == ELEMENT:
                        namespace, name, attributes, has_children = details
                        if (namespace and namespace != namespaces["html"]) or name not in void_elements:
                            yield self.end_tag(namespace, name)
                    if self.tree is current_node:
                        current_node = None
                        break
                    next_sibling = self.get_next_sibling(current_node)
                    if next_sibling is not None:
                        current_node = next_sibling
                        break
                    else:
                        current_node = self.get_parent_node(current_node)
