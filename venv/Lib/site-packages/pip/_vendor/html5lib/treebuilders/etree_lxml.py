"""Module for supporting the lxml.etree library. The idea here is to use as much
of the native library as possible, without using fragile hacks like custom element
names that break between releases. The downside of this is that we cannot represent
all possible trees; specifically the following are known to cause problems:

Text or comments as siblings of the root element
Docypes with no name

When any of these things occur, we emit a DataLossWarning
"""

from __future__ import absolute_import, division, unicode_literals
# pylint:disable=protected-access

import warnings
import re
import sys

try:
    from collections.abc import MutableMapping
except ImportError:
    from collections import MutableMapping

from . import base
from ..constants import DataLossWarning
from .. import constants
from . import etree as etree_builders
from .. import _ihatexml

import lxml.etree as etree
from pip._vendor.six import PY3, binary_type


full_tree = True
tag_regexp = re.compile("{([^}]*)}(.*)")

comment_type = etree.Comment("asd").tag


class DocumentType(object):
    def __init__(self, name, public_id, system_id):
        self.name = name
        self.public_id = public_id
        self.system_id = system_id


class Document(object):
    def __init__(self):
        self._element_tree = None
        self._child_nodes = []

    def append_child(self, element):
        last = self._element_tree.getroot()
        for last in self._element_tree.getroot().itersiblings():
            pass

        last.addnext(element._element)

    def _get_child_nodes(self):
        return self._child_nodes

    child_nodes = property(_get_child_nodes)


def test_serializer(element):
    rv = []
    infoset_filter = _ihatexml.InfosetFilter(prevent_double_dash_comments=True)

    def serialize_element(element, indent=0):
        if not hasattr(element, "tag"):
            if hasattr(element, "getroot"):
                # Full tree case
                rv.append("#document")
                if element.docinfo.internal_dtd:
                    if not (element.docinfo.public_id or
                            element.docinfo.system_url):
                        dtd_str = "<!DOCTYPE %s>" % element.docinfo.root_name
                    else:
                        dtd_str = """<!DOCTYPE %s "%s" "%s">""" % (
                            element.docinfo.root_name,
                            element.docinfo.public_id,
                            element.docinfo.system_url)
                    rv.append("|%s%s" % (' ' * (indent + 2), dtd_str))
                next_element = element.getroot()
                while next_element.getprevious() is not None:
                    next_element = next_element.getprevious()
                while next_element is not None:
                    serialize_element(next_element, indent + 2)
                    next_element = next_element.getnext()
            elif isinstance(element, str) or isinstance(element, bytes):
                # Text in a fragment
                assert isinstance(element, str) or sys.version_info[0] == 2
                rv.append("|%s\"%s\"" % (' ' * indent, element))
            else:
                # Fragment case
                rv.append("#document-fragment")
                for next_element in element:
                    serialize_element(next_element, indent + 2)
        elif element.tag == comment_type:
            rv.append("|%s<!-- %s -->" % (' ' * indent, element.text))
            if hasattr(element, "tail") and element.tail:
                rv.append("|%s\"%s\"" % (' ' * indent, element.tail))
        else:
            assert isinstance(element, etree._Element)
            nsmatch = etree_builders.tag_regexp.match(element.tag)
            if nsmatch is not None:
                ns = nsmatch.group(1)
                tag = nsmatch.group(2)
                prefix = constants.prefixes[ns]
                rv.append("|%s<%s %s>" % (' ' * indent, prefix,
                                          infoset_filter.from_xml_name(tag)))
            else:
                rv.append("|%s<%s>" % (' ' * indent,
                                       infoset_filter.from_xml_name(element.tag)))

            if hasattr(element, "attrib"):
                attributes = []
                for name, value in element.attrib.items():
                    nsmatch = tag_regexp.match(name)
                    if nsmatch is not None:
                        ns, name = nsmatch.groups()
                        name = infoset_filter.from_xml_name(name)
                        prefix = constants.prefixes[ns]
                        attr_string = "%s %s" % (prefix, name)
                    else:
                        attr_string = infoset_filter.from_xml_name(name)
                    attributes.append((attr_string, value))

                for name, value in sorted(attributes):
                    rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))

            if element.text:
                rv.append("|%s\"%s\"" % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serialize_element(child, indent)
            if hasattr(element, "tail") and element.tail:
                rv.append("|%s\"%s\"" % (' ' * (indent - 2), element.tail))
    serialize_element(element, 0)

    return "\n".join(rv)


def tostring(element):
    """Serialize an element and its child nodes to a string"""
    rv = []

    def serialize_element(element):
        if not hasattr(element, "tag"):
            if element.docinfo.internal_dtd:
                if element.docinfo.doctype:
                    dtd_str = element.docinfo.doctype
                else:
                    dtd_str = "<!DOCTYPE %s>" % element.docinfo.root_name
                rv.append(dtd_str)
            serialize_element(element.getroot())

        elif element.tag == comment_type:
            rv.append("<!--%s-->" % (element.text,))

        else:
            # This is assumed to be an ordinary element
            if not element.attrib:
                rv.append("<%s>" % (element.tag,))
            else:
                attr = " ".join(["%s=\"%s\"" % (name, value)
                                 for name, value in element.attrib.items()])
                rv.append("<%s %s>" % (element.tag, attr))
            if element.text:
                rv.append(element.text)

            for child in element:
                serialize_element(child)

            rv.append("</%s>" % (element.tag,))

        if hasattr(element, "tail") and element.tail:
            rv.append(element.tail)

    serialize_element(element)

    return "".join(rv)


class TreeBuilder(base.TreeBuilder):
    document_class = Document
    doctype_class = DocumentType
    element_class = None
    comment_class = None
    fragment_class = Document
    implementation = etree

    def __init__(self, namespace_html_elements, full_tree=False):
        builder = etree_builders.get_e_tree_module(etree, full_tree=full_tree)
        infoset_filter = self.infoset_filter = _ihatexml.InfosetFilter(prevent_double_dash_comments=True)
        self.namespace_html_elements = namespace_html_elements

        class Attributes(MutableMapping):
            def __init__(self, element):
                self._element = element

            def _coerce_key(self, key):
                if isinstance(key, tuple):
                    name = "{%s}%s" % (key[2], infoset_filter.coerce_attribute(key[1]))
                else:
                    name = infoset_filter.coerce_attribute(key)
                return name

            def __getitem__(self, key):
                value = self._element._element.attrib[self._coerce_key(key)]
                if not PY3 and isinstance(value, binary_type):
                    value = value.decode("ascii")
                return value

            def __setitem__(self, key, value):
                self._element._element.attrib[self._coerce_key(key)] = value

            def __delitem__(self, key):
                del self._element._element.attrib[self._coerce_key(key)]

            def __iter__(self):
                return iter(self._element._element.attrib)

            def __len__(self):
                return len(self._element._element.attrib)

            def clear(self):
                return self._element._element.attrib.clear()

        class Element(builder.Element):
            def __init__(self, name, namespace):
                name = infoset_filter.coerce_element(name)
                builder.Element.__init__(self, name, namespace=namespace)
                self._attributes = Attributes(self)

            def _set_name(self, name):
                self._name = infoset_filter.coerce_element(name)
                self._element.tag = self._get_e_tree_tag(
                    self._name, self._namespace)

            def _get_name(self):
                return infoset_filter.from_xml_name(self._name)

            name = property(_get_name, _set_name)

            def _get_attributes(self):
                return self._attributes

            def _set_attributes(self, value):
                attributes = self.attributes
                attributes.clear()
                attributes.update(value)

            attributes = property(_get_attributes, _set_attributes)

            def insert_text(self, data, insert_before=None):
                data = infoset_filter.coerce_characters(data)
                builder.Element.insert_text(self, data, insert_before)

            def clone_node(self):
                element = type(self)(self.name, self.namespace)
                if self._element.attrib:
                    element._element.attrib.update(self._element.attrib)
                return element

        class Comment(builder.Comment):
            def __init__(self, data):
                data = infoset_filter.coerce_comment(data)
                builder.Comment.__init__(self, data)

            def _set_data(self, data):
                data = infoset_filter.coerce_comment(data)
                self._element.text = data

            def _get_data(self):
                return self._element.text

            data = property(_get_data, _set_data)

        self.element_class = Element
        self.comment_class = Comment
        # self.fragment_class = builder.DocumentFragment
        base.TreeBuilder.__init__(self, namespace_html_elements)

    def reset(self):
        base.TreeBuilder.reset(self)
        self.insert_comment = self.insert_comment_initial
        self.initial_comments = []
        self.doctype = None

    def test_serializer(self, element):
        return test_serializer(element)

    def get_document(self):
        if full_tree:
            return self.document._element_tree
        else:
            return self.document._element_tree.getroot()

    def get_fragment(self):
        fragment = []
        element = self.open_elements[0]._element
        if element.text:
            fragment.append(element.text)
        fragment.extend(list(element))
        if element.tail:
            fragment.append(element.tail)
        return fragment

    def insert_doctype(self, token):
        name = token["name"]
        public_id = token["public_id"]
        system_id = token["system_id"]

        if not name:
            warnings.warn("lxml cannot represent empty doctype", DataLossWarning)
            self.doctype = None
        else:
            coerced_name = self.infoset_filter.coerce_element(name)
            if coerced_name != name:
                warnings.warn("lxml cannot represent non-xml doctype", DataLossWarning)

            doctype = self.doctype_class(coerced_name, public_id, system_id)
            self.doctype = doctype

    def insert_comment_initial(self, data, parent=None):
        assert parent is None or parent is self.document
        assert self.document._element_tree is None
        self.initial_comments.append(data)

    def insert_comment_main(self, data, parent=None):
        if (parent == self.document and
                self.document._element_tree.getroot()[-1].tag == comment_type):
            warnings.warn("lxml cannot represent adjacent comments beyond the root elements", DataLossWarning)
        super(TreeBuilder, self).insert_comment(data, parent)

    def insert_root(self, token):
        # Because of the way libxml2 works, it doesn't seem to be possible to
        # alter information like the doctype after the tree has been parsed.
        # Therefore we need to use the built-in parser to create our initial
        # tree, after which we can add elements like normal
        doc_str = ""
        if self.doctype:
            assert self.doctype.name
            doc_str += "<!DOCTYPE %s" % self.doctype.name
            if (self.doctype.public_id is not None or
                    self.doctype.system_id is not None):
                doc_str += (' PUBLIC "%s" ' %
                           (self.infoset_filter.coerce_pubid(self.doctype.public_id or "")))
                if self.doctype.system_id:
                    sysid = self.doctype.system_id
                    if sysid.find("'") >= 0 and sysid.find('"') >= 0:
                        warnings.warn("DOCTYPE system cannot contain single and double quotes", DataLossWarning)
                        sysid = sysid.replace("'", 'U00027')
                    if sysid.find("'") >= 0:
                        doc_str += '"%s"' % sysid
                    else:
                        doc_str += "'%s'" % sysid
                else:
                    doc_str += "''"
            doc_str += ">"
            if self.doctype.name != token["name"]:
                warnings.warn("lxml cannot represent doctype with a different name to the root element", DataLossWarning)
        doc_str += "<THIS_SHOULD_NEVER_APPEAR_PUBLICLY/>"
        root = etree.fromstring(doc_str)

        # Append the initial comments:
        for comment_token in self.initial_comments:
            comment = self.comment_class(comment_token["data"])
            root.addprevious(comment._element)

        # Create the root document and add the ElementTree to it
        self.document = self.document_class()
        self.document._element_tree = root.getroottree()

        # Give the root element the right name
        name = token["name"]
        namespace = token.get("namespace", self.default_namespace)
        if namespace is None:
            etree_tag = name
        else:
            etree_tag = "{%s}%s" % (namespace, name)
        root.tag = etree_tag

        # Add the root element to the internal child/open data structures
        root_element = self.element_class(name, namespace)
        root_element._element = root
        self.document._child_nodes.append(root_element)
        self.open_elements.append(root_element)

        # Reset to the default insert comment function
        self.insert_comment = self.insert_comment_main
