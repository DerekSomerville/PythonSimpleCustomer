from __future__ import absolute_import, division, unicode_literals


try:
    from collections.abc import MutableMapping
except ImportError:  # Python 2.7
    from collections import MutableMapping
from xml.dom import minidom, Node
import weakref

from . import base
from .. import constants
from ..constants import namespaces
from .._utils import module_factory_factory


def get_dom_builder(DomImplementation):
    Dom = DomImplementation

    class AttrList(MutableMapping):
        def __init__(self, element):
            self.element = element

        def __iter__(self):
            return iter(self.element.attributes.keys())

        def __setitem__(self, name, value):
            if isinstance(name, tuple):
                raise NotImplementedError
            else:
                attr = self.element.owner_document.create_attribute(name)
                attr.value = value
                self.element.attributes[name] = attr

        def __len__(self):
            return len(self.element.attributes)

        def items(self):
            return list(self.element.attributes.items())

        def values(self):
            return list(self.element.attributes.values())

        def __getitem__(self, name):
            if isinstance(name, tuple):
                raise NotImplementedError
            else:
                return self.element.attributes[name].value

        def __delitem__(self, name):
            if isinstance(name, tuple):
                raise NotImplementedError
            else:
                del self.element.attributes[name]

    class NodeBuilder(base.Node):
        def __init__(self, element):
            base.Node.__init__(self, element.node_name)
            self.element = element

        namespace = property(lambda self: hasattr(self.element, "namespace_uri") and
                             self.element.namespace_uri or None)

        def append_child(self, node):
            node.parent = self
            self.element.append_child(node.element)

        def insert_text(self, data, insert_before=None):
            text = self.element.owner_document.create_text_node(data)
            if insert_before:
                self.element.insert_before(text, insert_before.element)
            else:
                self.element.append_child(text)

        def insert_before(self, node, ref_node):
            self.element.insert_before(node.element, ref_node.element)
            node.parent = self

        def remove_child(self, node):
            if node.element.parent_node == self.element:
                self.element.remove_child(node.element)
            node.parent = None

        def reparent_children(self, new_parent):
            while self.element.has_child_nodes():
                child = self.element.first_child
                self.element.remove_child(child)
                new_parent.element.append_child(child)
            self.child_nodes = []

        def get_attributes(self):
            return AttrList(self.element)

        def set_attributes(self, attributes):
            if attributes:
                for name, value in list(attributes.items()):
                    if isinstance(name, tuple):
                        if name[0] is not None:
                            qualified_name = (name[0] + ":" + name[1])
                        else:
                            qualified_name = name[1]
                        self.element.set_attribute_ns(name[2], qualified_name,
                                                    value)
                    else:
                        self.element.set_attribute(
                            name, value)
        attributes = property(get_attributes, set_attributes)

        def clone_node(self):
            return NodeBuilder(self.element.clone_node(False))

        def has_content(self):
            return self.element.has_child_nodes()

        def get_name_tuple(self):
            if self.namespace is None:
                return namespaces["html"], self.name
            else:
                return self.namespace, self.name

        name_tuple = property(get_name_tuple)

    class TreeBuilder(base.TreeBuilder):  # pylint:disable=unused-variable
        def document_class(self):
            self.dom = Dom.get_dom_implementation().create_document(None, None, None)
            return weakref.proxy(self)

        def insert_doctype(self, token):
            name = token["name"]
            public_id = token["public_id"]
            system_id = token["system_id"]

            domimpl = Dom.get_dom_implementation()
            doctype = domimpl.create_document_type(name, public_id, system_id)
            self.document.append_child(NodeBuilder(doctype))
            if Dom == minidom:
                doctype.owner_document = self.dom

        def element_class(self, name, namespace=None):
            if namespace is None and self.default_namespace is None:
                node = self.dom.create_element(name)
            else:
                node = self.dom.create_element_ns(namespace, name)

            return NodeBuilder(node)

        def comment_class(self, data):
            return NodeBuilder(self.dom.create_comment(data))

        def fragment_class(self):
            return NodeBuilder(self.dom.create_document_fragment())

        def append_child(self, node):
            self.dom.append_child(node.element)

        def test_serializer(self, element):
            return test_serializer(element)

        def get_document(self):
            return self.dom

        def get_fragment(self):
            return base.TreeBuilder.get_fragment(self).element

        def insert_text(self, data, parent=None):
            data = data
            if parent != self:
                base.TreeBuilder.insert_text(self, data, parent)
            else:
                # HACK: allow text nodes as children of the document node
                if hasattr(self.dom, '_child_node_types'):
                    # pylint:disable=protected-access
                    if Node.TEXT_NODE not in self.dom._child_node_types:
                        self.dom._child_node_types = list(self.dom._child_node_types)
                        self.dom._child_node_types.append(Node.TEXT_NODE)
                self.dom.append_child(self.dom.create_text_node(data))

        implementation = DomImplementation
        name = None

    def test_serializer(element):
        element.normalize()
        rv = []

        def serialize_element(element, indent=0):
            if element.node_type == Node.DOCUMENT_TYPE_NODE:
                if element.name:
                    if element.public_id or element.system_id:
                        public_id = element.public_id or ""
                        system_id = element.system_id or ""
                        rv.append("""|%s<!DOCTYPE %s "%s" "%s">""" %
                                  (' ' * indent, element.name, public_id, system_id))
                    else:
                        rv.append("|%s<!DOCTYPE %s>" % (' ' * indent, element.name))
                else:
                    rv.append("|%s<!DOCTYPE >" % (' ' * indent,))
            elif element.node_type == Node.DOCUMENT_NODE:
                rv.append("#document")
            elif element.node_type == Node.DOCUMENT_FRAGMENT_NODE:
                rv.append("#document-fragment")
            elif element.node_type == Node.COMMENT_NODE:
                rv.append("|%s<!-- %s -->" % (' ' * indent, element.node_value))
            elif element.node_type == Node.TEXT_NODE:
                rv.append("|%s\"%s\"" % (' ' * indent, element.node_value))
            else:
                if (hasattr(element, "namespace_uri") and
                        element.namespace_uri is not None):
                    name = "%s %s" % (constants.prefixes[element.namespace_uri],
                                      element.node_name)
                else:
                    name = element.node_name
                rv.append("|%s<%s>" % (' ' * indent, name))
                if element.has_attributes():
                    attributes = []
                    for i in range(len(element.attributes)):
                        attr = element.attributes.item(i)
                        name = attr.node_name
                        value = attr.value
                        ns = attr.namespace_uri
                        if ns:
                            name = "%s %s" % (constants.prefixes[ns], attr.local_name)
                        else:
                            name = attr.node_name
                        attributes.append((name, value))

                    for name, value in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
            indent += 2
            for child in element.child_nodes:
                serialize_element(child, indent)
        serialize_element(element, 0)

        return "\n".join(rv)

    return locals()


# The actual means to get a module!
get_dom_module = module_factory_factory(get_dom_builder)
