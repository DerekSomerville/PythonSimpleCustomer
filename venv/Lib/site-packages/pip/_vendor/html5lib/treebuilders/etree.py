from __future__ import absolute_import, division, unicode_literals
# pylint:disable=protected-access

from pip._vendor.six import text_type

import re

from copy import copy

from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import module_factory_factory

tag_regexp = re.compile("{([^}]*)}(.*)")


def get_e_tree_builder(ElementTreeImplementation, full_tree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment("asd").tag

    class Element(base.Node):
        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._get_e_tree_tag(name,
                                                                  namespace))
            if namespace is None:
                self.name_tuple = namespaces["html"], self._name
            else:
                self.name_tuple = self._namespace, self._name
            self.parent = None
            self._child_nodes = []
            self._flags = []

        def _get_e_tree_tag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = "{%s}%s" % (namespace, name)
            return etree_tag

        def _set_name(self, name):
            self._name = name
            self._element.tag = self._get_e_tree_tag(self._name, self._namespace)

        def _get_name(self):
            return self._name

        name = property(_get_name, _set_name)

        def _set_namespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._get_e_tree_tag(self._name, self._namespace)

        def _get_namespace(self):
            return self._namespace

        namespace = property(_get_namespace, _set_namespace)

        def _get_attributes(self):
            return self._element.attrib

        def _set_attributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                # calling .items _always_ allocates, and the above truthy check is cheaper than the
                # allocation on average
                for key, value in attributes.items():
                    if isinstance(key, tuple):
                        name = "{%s}%s" % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value

        attributes = property(_get_attributes, _set_attributes)

        def _get_child_nodes(self):
            return self._child_nodes

        def _set_child_nodes(self, value):
            del self._element[:]
            self._child_nodes = []
            for element in value:
                self.insert_child(element)

        child_nodes = property(_get_child_nodes, _set_child_nodes)

        def has_content(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def append_child(self, node):
            self._child_nodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insert_before(self, node, ref_node):
            index = list(self._element).index(ref_node._element)
            self._element.insert(index, node._element)
            node.parent = self

        def remove_child(self, node):
            self._child_nodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insert_text(self, data, insert_before=None):
            if not(len(self._element)):
                if not self._element.text:
                    self._element.text = ""
                self._element.text += data
            elif insert_before is None:
                # Insert the text as the tail of the last child element
                if not self._element[-1].tail:
                    self._element[-1].tail = ""
                self._element[-1].tail += data
            else:
                # Insert the text before the specified node
                children = list(self._element)
                index = children.index(insert_before._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ""
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ""
                    self._element.text += data

        def clone_node(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparent_children(self, new_parent):
            if new_parent.child_nodes:
                new_parent.child_nodes[-1]._element.tail += self._element.text
            else:
                if not new_parent._element.text:
                    new_parent._element.text = ""
                if self._element.text is not None:
                    new_parent._element.text += self._element.text
            self._element.text = ""
            base.Node.reparent_children(self, new_parent)

    class Comment(Element):
        def __init__(self, data):
            # Use the superclass constructor to set all properties on the
            # wrapper element
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._child_nodes = []
            self._flags = []

        def _get_data(self):
            return self._element.text

        def _set_data(self, value):
            self._element.text = value

        data = property(_get_data, _set_data)

    class DocumentType(Element):
        def __init__(self, name, public_id, system_id):
            Element.__init__(self, "<!DOCTYPE>")
            self._element.text = name
            self.public_id = public_id
            self.system_id = system_id

        def _get_public_id(self):
            return self._element.get("public_id", "")

        def _set_public_id(self, value):
            if value is not None:
                self._element.set("public_id", value)

        public_id = property(_get_public_id, _set_public_id)

        def _get_system_id(self):
            return self._element.get("system_id", "")

        def _set_system_id(self, value):
            if value is not None:
                self._element.set("system_id", value)

        system_id = property(_get_system_id, _set_system_id)

    class Document(Element):
        def __init__(self):
            Element.__init__(self, "DOCUMENT_ROOT")

    class DocumentFragment(Element):
        def __init__(self):
            Element.__init__(self, "DOCUMENT_FRAGMENT")

    def test_serializer(element):
        rv = []

        def serialize_element(element, indent=0):
            if not(hasattr(element, "tag")):
                element = element.getroot()
            if element.tag == "<!DOCTYPE>":
                if element.get("public_id") or element.get("system_id"):
                    public_id = element.get("public_id") or ""
                    system_id = element.get("system_id") or ""
                    rv.append("""<!DOCTYPE %s "%s" "%s">""" %
                              (element.text, public_id, system_id))
                else:
                    rv.append("<!DOCTYPE %s>" % (element.text,))
            elif element.tag == "DOCUMENT_ROOT":
                rv.append("#document")
                if element.text is not None:
                    rv.append("|%s\"%s\"" % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError("Document node cannot have tail")
                if hasattr(element, "attrib") and len(element.attrib):
                    raise TypeError("Document node cannot have attributes")
            elif element.tag == ElementTreeCommentType:
                rv.append("|%s<!-- %s -->" % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), \
                    "Expected unicode, got %s, %s" % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)

                if nsmatch is None:
                    name = element.tag
                else:
                    ns, name = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = "%s %s" % (prefix, name)
                rv.append("|%s<%s>" % (' ' * indent, name))

                if hasattr(element, "attrib"):
                    attributes = []
                    for name, value in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            ns, name = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = "%s %s" % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))

                    for name, value in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append("|%s\"%s\"" % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serialize_element(child, indent)
            if element.tail:
                rv.append("|%s\"%s\"" % (' ' * (indent - 2), element.tail))
        serialize_element(element, 0)

        return "\n".join(rv)

    def tostring(element):  # pylint:disable=unused-variable
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serialize_element(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()

            if element.tag == "<!DOCTYPE>":
                if element.get("public_id") or element.get("system_id"):
                    public_id = element.get("public_id") or ""
                    system_id = element.get("system_id") or ""
                    rv.append("""<!DOCTYPE %s PUBLIC "%s" "%s">""" %
                              (element.text, public_id, system_id))
                else:
                    rv.append("<!DOCTYPE %s>" % (element.text,))
            elif element.tag == "DOCUMENT_ROOT":
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError("Document node cannot have tail")
                if hasattr(element, "attrib") and len(element.attrib):
                    raise TypeError("Document node cannot have attributes")

                for child in element:
                    serialize_element(child)

            elif element.tag == ElementTreeCommentType:
                rv.append("<!--%s-->" % (element.text,))
            else:
                # This is assumed to be an ordinary element
                if not element.attrib:
                    rv.append("<%s>" % (filter.from_xml_name(element.tag),))
                else:
                    attr = " ".join(["%s=\"%s\"" % (
                        filter.from_xml_name(name), value)
                        for name, value in element.attrib.items()])
                    rv.append("<%s %s>" % (element.tag, attr))
                if element.text:
                    rv.append(element.text)

                for child in element:
                    serialize_element(child)

                rv.append("</%s>" % (element.tag,))

            if element.tail:
                rv.append(element.tail)

        serialize_element(element)

        return "".join(rv)

    class TreeBuilder(base.TreeBuilder):  # pylint:disable=unused-variable
        document_class = Document
        doctype_class = DocumentType
        element_class = Element
        comment_class = Comment
        fragment_class = DocumentFragment
        implementation = ElementTreeImplementation

        def test_serializer(self, element):
            return test_serializer(element)

        def get_document(self):
            if full_tree:
                return self.document._element
            else:
                if self.default_namespace is not None:
                    return self.document._element.find(
                        "{%s}html" % self.default_namespace)
                else:
                    return self.document._element.find("html")

        def get_fragment(self):
            return base.TreeBuilder.get_fragment(self)._element

    return locals()


get_e_tree_module = module_factory_factory(get_e_tree_builder)
