from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import text_type

from ..constants import scoping_elements, table_insert_mode_elements, namespaces

# The scope markers are inserted when entering object elements,
# marquees, table cells, and table captions, and are used to prevent formatting
# from "leaking" into tables, object elements, and marquees.
Marker = None

list_elements_map = {
    None: (frozenset(scoping_elements), False),
    "button": (frozenset(scoping_elements | {(namespaces["html"], "button")}), False),
    "list": (frozenset(scoping_elements | {(namespaces["html"], "ol"),
                                          (namespaces["html"], "ul")}), False),
    "table": (frozenset([(namespaces["html"], "html"),
                         (namespaces["html"], "table")]), False),
    "select": (frozenset([(namespaces["html"], "optgroup"),
                          (namespaces["html"], "option")]), True)
}


class Node(object):
    """Represents an item in the tree"""
    def __init__(self, name):
        """Creates a Node

        :arg name: The tag name associated with the node

        """
        # The tag name associated with the node
        self.name = name
        # The parent of the current node (or None for the document node)
        self.parent = None
        # The value of the current node (applies to text nodes and comments)
        self.value = None
        # A dict holding name -> value pairs for attributes of the node
        self.attributes = {}
        # A list of child nodes of the current node. This must include all
        # elements but not necessarily other node types.
        self.child_nodes = []
        # A list of miscellaneous flags that can be set on the node.
        self._flags = []

    def __str__(self):
        attributes_str = " ".join(["%s=\"%s\"" % (name, value)
                                  for name, value in
                                  self.attributes.items()])
        if attributes_str:
            return "<%s %s>" % (self.name, attributes_str)
        else:
            return "<%s>" % (self.name)

    def __repr__(self):
        return "<%s>" % (self.name)

    def append_child(self, node):
        """Insert node as a child of the current node

        :arg node: the node to insert

        """
        raise NotImplementedError

    def insert_text(self, data, insert_before=None):
        """Insert data as text in the current node, positioned before the
        start of node insert_before or to the end of the node's text.

        :arg data: the data to insert

        :arg insert_before: True if you want to insert the text before the node
            and False if you want to insert it after the node

        """
        raise NotImplementedError

    def insert_before(self, node, ref_node):
        """Insert node as a child of the current node, before ref_node in the
        list of child nodes. Raises ValueError if ref_node is not a child of
        the current node

        :arg node: the node to insert

        :arg ref_node: the child node to insert the node before

        """
        raise NotImplementedError

    def remove_child(self, node):
        """Remove node from the children of the current node

        :arg node: the child node to remove

        """
        raise NotImplementedError

    def reparent_children(self, new_parent):
        """Move all the children of the current node to new_parent.
        This is needed so that trees that don't store text as nodes move the
        text in the correct way

        :arg new_parent: the node to move all this node's children to

        """
        # XXX - should this method be made more general?
        for child in self.child_nodes:
            new_parent.append_child(child)
        self.child_nodes = []

    def clone_node(self):
        """Return a shallow copy of the current node i.e. a node with the same
        name and attributes but with no parent or child nodes
        """
        raise NotImplementedError

    def has_content(self):
        """Return true if the node has children or text, false otherwise
        """
        raise NotImplementedError


class ActiveFormattingElements(list):
    def append(self, node):
        equal_count = 0
        if node != Marker:
            for element in self[::-1]:
                if element == Marker:
                    break
                if self.nodes_equal(element, node):
                    equal_count += 1
                if equal_count == 3:
                    self.remove(element)
                    break
        list.append(self, node)

    def nodes_equal(self, node1, node2):
        if not node1.name_tuple == node2.name_tuple:
            return False

        if not node1.attributes == node2.attributes:
            return False

        return True


class TreeBuilder(object):
    """Base treebuilder implementation

    * document_class - the class to use for the bottommost node of a document
    * element_class - the class to use for HTML Elements
    * comment_class - the class to use for comments
    * doctype_class - the class to use for doctypes

    """
    # pylint:disable=not-callable

    # Document class
    document_class = None

    # The class to use for creating a node
    element_class = None

    # The class to use for creating comments
    comment_class = None

    # The class to use for creating doctypes
    doctype_class = None

    # Fragment class
    fragment_class = None

    def __init__(self, namespace_html_elements):
        """Create a TreeBuilder

        :arg namespace_html_elements: whether or not to namespace HTML elements

        """
        if namespace_html_elements:
            self.default_namespace = "http://www.w3.org/1999/xhtml"
        else:
            self.default_namespace = None
        self.reset()

    def reset(self):
        self.open_elements = []
        self.active_formatting_elements = ActiveFormattingElements()

        # XXX - rename these to head_element, form_element
        self.head_pointer = None
        self.form_pointer = None

        self.insert_from_table = False

        self.document = self.document_class()

    def element_in_scope(self, target, variant=None):

        # If we pass a node in we match that. if we pass a string
        # match any node with that name
        exact_node = hasattr(target, "name_tuple")
        if not exact_node:
            if isinstance(target, text_type):
                target = (namespaces["html"], target)
            assert isinstance(target, tuple)

        list_elements, invert = list_elements_map[variant]

        for node in reversed(self.open_elements):
            if exact_node and node == target:
                return True
            elif not exact_node and node.name_tuple == target:
                return True
            elif (invert ^ (node.name_tuple in list_elements)):
                return False

        assert False  # We should never reach this point

    def reconstruct_active_formatting_elements(self):
        # Within this algorithm the order of steps described in the
        # specification is not quite the same as the order of steps in the
        # code. It should still do the same though.

        # Step 1: stop the algorithm when there's nothing to do.
        if not self.active_formatting_elements:
            return

        # Step 2 and step 3: we start with the last element. So i is -1.
        i = len(self.active_formatting_elements) - 1
        entry = self.active_formatting_elements[i]
        if entry == Marker or entry in self.open_elements:
            return

        # Step 6
        while entry != Marker and entry not in self.open_elements:
            if i == 0:
                # This will be reset to 0 below
                i = -1
                break
            i -= 1
            # Step 5: let entry be one earlier in the list.
            entry = self.active_formatting_elements[i]

        while True:
            # Step 7
            i += 1

            # Step 8
            entry = self.active_formatting_elements[i]
            clone = entry.clone_node()  # Mainly to get a new copy of the attributes

            # Step 9
            element = self.insert_element({"type": "StartTag",
                                          "name": clone.name,
                                          "namespace": clone.namespace,
                                          "data": clone.attributes})

            # Step 10
            self.active_formatting_elements[i] = element

            # Step 11
            if element == self.active_formatting_elements[-1]:
                break

    def clear_active_formatting_elements(self):
        entry = self.active_formatting_elements.pop()
        while self.active_formatting_elements and entry != Marker:
            entry = self.active_formatting_elements.pop()

    def element_in_active_formatting_elements(self, name):
        """Check if an element exists between the end of the active
        formatting elements and the last marker. If it does, return it, else
        return false"""

        for item in self.active_formatting_elements[::-1]:
            # Check for Marker first because if it's a Marker it doesn't have a
            # name attribute.
            if item == Marker:
                break
            elif item.name == name:
                return item
        return False

    def insert_root(self, token):
        element = self.create_element(token)
        self.open_elements.append(element)
        self.document.append_child(element)

    def insert_doctype(self, token):
        name = token["name"]
        public_id = token["public_id"]
        system_id = token["system_id"]

        doctype = self.doctype_class(name, public_id, system_id)
        self.document.append_child(doctype)

    def insert_comment(self, token, parent=None):
        if parent is None:
            parent = self.open_elements[-1]
        parent.append_child(self.comment_class(token["data"]))

    def create_element(self, token):
        """Create an element but don't insert it anywhere"""
        name = token["name"]
        namespace = token.get("namespace", self.default_namespace)
        element = self.element_class(name, namespace)
        element.attributes = token["data"]
        return element

    def _get_insert_from_table(self):
        return self._insert_from_table

    def _set_insert_from_table(self, value):
        """Switch the function used to insert an element from the
        normal one to the misnested table one and back again"""
        self._insert_from_table = value
        if value:
            self.insert_element = self.insert_element_table
        else:
            self.insert_element = self.insert_element_normal

    insert_from_table = property(_get_insert_from_table, _set_insert_from_table)

    def insert_element_normal(self, token):
        name = token["name"]
        assert isinstance(name, text_type), "Element %s not unicode" % name
        namespace = token.get("namespace", self.default_namespace)
        element = self.element_class(name, namespace)
        element.attributes = token["data"]
        self.open_elements[-1].append_child(element)
        self.open_elements.append(element)
        return element

    def insert_element_table(self, token):
        """Create an element and insert it into the tree"""
        element = self.create_element(token)
        if self.open_elements[-1].name not in table_insert_mode_elements:
            return self.insert_element_normal(token)
        else:
            # We should be in the InTable mode. This means we want to do
            # special magic element rearranging
            parent, insert_before = self.get_table_misnested_node_position()
            if insert_before is None:
                parent.append_child(element)
            else:
                parent.insert_before(element, insert_before)
            self.open_elements.append(element)
        return element

    def insert_text(self, data, parent=None):
        """Insert text data."""
        if parent is None:
            parent = self.open_elements[-1]

        if (not self.insert_from_table or (self.insert_from_table and
                                         self.open_elements[-1].name
                                         not in table_insert_mode_elements)):
            parent.insert_text(data)
        else:
            # We should be in the InTable mode. This means we want to do
            # special magic element rearranging
            parent, insert_before = self.get_table_misnested_node_position()
            parent.insert_text(data, insert_before)

    def get_table_misnested_node_position(self):
        """Get the foster parent element, and sibling to insert before
        (or None) when inserting a misnested table node"""
        # The foster parent element is the one which comes before the most
        # recently opened table element
        # XXX - this is really inelegant
        last_table = None
        foster_parent = None
        insert_before = None
        for elm in self.open_elements[::-1]:
            if elm.name == "table":
                last_table = elm
                break
        if last_table:
            # XXX - we should really check that this parent is actually a
            # node here
            if last_table.parent:
                foster_parent = last_table.parent
                insert_before = last_table
            else:
                foster_parent = self.open_elements[
                    self.open_elements.index(last_table) - 1]
        else:
            foster_parent = self.open_elements[0]
        return foster_parent, insert_before

    def generate_implied_end_tags(self, exclude=None):
        name = self.open_elements[-1].name
        # XXX td, th and tr are not actually needed
        if (name in frozenset(("dd", "dt", "li", "option", "optgroup", "p", "rp", "rt")) and
                name != exclude):
            self.open_elements.pop()
            # XXX This is not entirely what the specification says. We should
            # investigate it more closely.
            self.generate_implied_end_tags(exclude)

    def get_document(self):
        """Return the final tree"""
        return self.document

    def get_fragment(self):
        """Return the final fragment"""
        # assert self.inner_html
        fragment = self.fragment_class()
        self.open_elements[0].reparent_children(fragment)
        return fragment

    def test_serializer(self, node):
        """Serialize the subtree of node in the format required by unit tests

        :arg node: the node from which to start serializing

        """
        raise NotImplementedError
