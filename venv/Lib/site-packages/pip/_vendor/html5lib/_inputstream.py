from __future__ import absolute_import, division, unicode_literals

from pip._vendor.six import text_type
from pip._vendor.six.moves import http_client, urllib

import codecs
import re
from io import BytesIO, StringIO

from pip._vendor import webencodings

from .constants import EOF, space_characters, ascii_letters, ascii_uppercase
from .constants import _ReparseException
from . import _utils

# Non-unicode versions of constants for use in the pre-parser
space_characters_bytes = frozenset([item.encode("ascii") for item in space_characters])
ascii_letters_bytes = frozenset([item.encode("ascii") for item in ascii_letters])
ascii_uppercase_bytes = frozenset([item.encode("ascii") for item in ascii_uppercase])
spaces_angle_brackets = space_characters_bytes | frozenset([b">", b"<"])


invalid_unicode_no_surrogate = "[\u0001-\u0008\u000_b\u000_e-\u001_f\u007_f-\u009_f\u_fdd0-\u_fdef\u_fffe\u_ffff\U0001FFFE\U0001FFFF\U0002FFFE\U0002FFFF\U0003FFFE\U0003FFFF\U0004FFFE\U0004FFFF\U0005FFFE\U0005FFFF\U0006FFFE\U0006FFFF\U0007FFFE\U0007FFFF\U0008FFFE\U0008FFFF\U0009FFFE\U0009FFFF\U000AFFFE\U000AFFFF\U000BFFFE\U000BFFFF\U000CFFFE\U000CFFFF\U000DFFFE\U000DFFFF\U000EFFFE\U000EFFFF\U000FFFFE\U000FFFFF\U0010FFFE\U0010FFFF]"  # noqa

if _utils.supports_lone_surrogates:
    # Use one extra step of indirection and create surrogates with
    # eval. Not using this indirection would introduce an illegal
    # unicode literal on platforms not supporting such lone
    # surrogates.
    assert invalid_unicode_no_surrogate[-1] == "]" and invalid_unicode_no_surrogate.count("]") == 1
    invalid_unicode_re = re.compile(invalid_unicode_no_surrogate[:-1] +
                                    eval('"\\u_d800-\\u_dfff"') +  # pylint:disable=eval-used
                                    "]")
else:
    invalid_unicode_re = re.compile(invalid_unicode_no_surrogate)

non_bmp_invalid_codepoints = {0x1FFFE, 0x1FFFF, 0x2FFFE, 0x2FFFF, 0x3FFFE,
                              0x3FFFF, 0x4FFFE, 0x4FFFF, 0x5FFFE, 0x5FFFF,
                              0x6FFFE, 0x6FFFF, 0x7FFFE, 0x7FFFF, 0x8FFFE,
                              0x8FFFF, 0x9FFFE, 0x9FFFF, 0xAFFFE, 0xAFFFF,
                              0xBFFFE, 0xBFFFF, 0xCFFFE, 0xCFFFF, 0xDFFFE,
                              0xDFFFF, 0xEFFFE, 0xEFFFF, 0xFFFFE, 0xFFFFF,
                              0x10FFFE, 0x10FFFF}

ascii_punctuation_re = re.compile("[\u0009-\u000_d\u0020-\u002_f\u003_a-\u0040\u005_c\u005_b-\u0060\u007_b-\u007_e]")

# Cache for chars_until()
chars_until_reg_ex = {}


class BufferedStream(object):
    """Buffering for streams that do not have buffering of their own

    The buffer is implemented as a list of chunks on the assumption that
    joining many strings will be slow since it is O(n**2)
    """

    def __init__(self, stream):
        self.stream = stream
        self.buffer = []
        self.position = [-1, 0]  # chunk number, offset

    def tell(self):
        pos = 0
        for chunk in self.buffer[:self.position[0]]:
            pos += len(chunk)
        pos += self.position[1]
        return pos

    def seek(self, pos):
        assert pos <= self._buffered_bytes()
        offset = pos
        i = 0
        while len(self.buffer[i]) < offset:
            offset -= len(self.buffer[i])
            i += 1
        self.position = [i, offset]

    def read(self, bytes):
        if not self.buffer:
            return self._read_stream(bytes)
        elif (self.position[0] == len(self.buffer) and
              self.position[1] == len(self.buffer[-1])):
            return self._read_stream(bytes)
        else:
            return self._read_from_buffer(bytes)

    def _buffered_bytes(self):
        return sum([len(item) for item in self.buffer])

    def _read_stream(self, bytes):
        data = self.stream.read(bytes)
        self.buffer.append(data)
        self.position[0] += 1
        self.position[1] = len(data)
        return data

    def _read_from_buffer(self, bytes):
        remaining_bytes = bytes
        rv = []
        buffer_index = self.position[0]
        buffer_offset = self.position[1]
        while buffer_index < len(self.buffer) and remaining_bytes != 0:
            assert remaining_bytes > 0
            buffered_data = self.buffer[buffer_index]

            if remaining_bytes <= len(buffered_data) - buffer_offset:
                bytes_to_read = remaining_bytes
                self.position = [buffer_index, buffer_offset + bytes_to_read]
            else:
                bytes_to_read = len(buffered_data) - buffer_offset
                self.position = [buffer_index, len(buffered_data)]
                buffer_index += 1
            rv.append(buffered_data[buffer_offset:buffer_offset + bytes_to_read])
            remaining_bytes -= bytes_to_read

            buffer_offset = 0

        if remaining_bytes:
            rv.append(self._read_stream(remaining_bytes))

        return b"".join(rv)


def HTMLInputStream(source, **kwargs):
    # Work around Python bug #20007: read(0) closes the connection.
    # http://bugs.python.org/issue20007
    if (isinstance(source, http_client.HTTPResponse) or
        # Also check for addinfourl wrapping HTTPResponse
        (isinstance(source, urllib.response.addbase) and
         isinstance(source.fp, http_client.HTTPResponse))):
        is_unicode = False
    elif hasattr(source, "read"):
        is_unicode = isinstance(source.read(0), text_type)
    else:
        is_unicode = isinstance(source, text_type)

    if is_unicode:
        encodings = [x for x in kwargs if x.endswith("_encoding")]
        if encodings:
            raise TypeError("Cannot set an encoding with a unicode input, set %r" % encodings)

        return HTMLUnicodeInputStream(source, **kwargs)
    else:
        return HTMLBinaryInputStream(source, **kwargs)


class HTMLUnicodeInputStream(object):
    """Provides a unicode stream of characters to the HTMLTokenizer.

    This class takes care of character encoding and removing or replacing
    incorrect byte-sequences and also provides column and line tracking.

    """

    _default_chunk_size = 10240

    def __init__(self, source):
        """Initialises the HTMLInputStream.

        HTMLInputStream(source, [encoding]) -> Normalized stream from source
        for use by html5lib.

        source can be either a file-object, local filename or a string.

        The optional encoding parameter must be a string that indicates
        the encoding.  If specified, that encoding will be used,
        regardless of any BOM or later declaration (such as in a meta
        element)

        """

        if not _utils.supports_lone_surrogates:
            # Such platforms will have already checked for such
            # surrogate errors, so no need to do this checking.
            self.report_character_errors = None
        elif len("\U0010FFFF") == 1:
            self.report_character_errors = self.character_errors_ucs4
        else:
            self.report_character_errors = self.character_errors_ucs2

        # List of where new lines occur
        self.new_lines = [0]

        self.char_encoding = (lookup_encoding("utf-8"), "certain")
        self.data_stream = self.open_stream(source)

        self.reset()

    def reset(self):
        self.chunk = ""
        self.chunk_size = 0
        self.chunk_offset = 0
        self.errors = []

        # number of (complete) lines in previous chunks
        self.prev_num_lines = 0
        # number of columns in the last line of the previous chunk
        self.prev_num_cols = 0

        # Deal with CR LF and surrogates split over chunk boundaries
        self._buffered_character = None

    def open_stream(self, source):
        """Produces a file object from source.

        source can be either a file object, local filename or a string.

        """
        # Already a file object
        if hasattr(source, 'read'):
            stream = source
        else:
            stream = StringIO(source)

        return stream

    def _position(self, offset):
        chunk = self.chunk
        n_lines = chunk.count('\n', 0, offset)
        position_line = self.prev_num_lines + n_lines
        last_line_pos = chunk.rfind('\n', 0, offset)
        if last_line_pos == -1:
            position_column = self.prev_num_cols + offset
        else:
            position_column = offset - (last_line_pos + 1)
        return (position_line, position_column)

    def position(self):
        """Returns (line, col) of the current position in the stream."""
        line, col = self._position(self.chunk_offset)
        return (line + 1, col)

    def char(self):
        """ Read one character from the stream or queue if available. Return
            EOF when EOF is reached.
        """
        # Read a new chunk from the input stream if necessary
        if self.chunk_offset >= self.chunk_size:
            if not self.read_chunk():
                return EOF

        chunk_offset = self.chunk_offset
        char = self.chunk[chunk_offset]
        self.chunk_offset = chunk_offset + 1

        return char

    def read_chunk(self, chunk_size=None):
        if chunk_size is None:
            chunk_size = self._default_chunk_size

        self.prev_num_lines, self.prev_num_cols = self._position(self.chunk_size)

        self.chunk = ""
        self.chunk_size = 0
        self.chunk_offset = 0

        data = self.data_stream.read(chunk_size)

        # Deal with CR LF and surrogates broken across chunks
        if self._buffered_character:
            data = self._buffered_character + data
            self._buffered_character = None
        elif not data:
            # We have no more data, bye-bye stream
            return False

        if len(data) > 1:
            lastv = ord(data[-1])
            if lastv == 0x0D or 0xD800 <= lastv <= 0xDBFF:
                self._buffered_character = data[-1]
                data = data[:-1]

        if self.report_character_errors:
            self.report_character_errors(data)

        # Replace invalid characters
        data = data.replace("\r\n", "\n")
        data = data.replace("\r", "\n")

        self.chunk = data
        self.chunk_size = len(data)

        return True

    def character_errors_ucs4(self, data):
        for _ in range(len(invalid_unicode_re.findall(data))):
            self.errors.append("invalid-codepoint")

    def character_errors_ucs2(self, data):
        # Someone picked the wrong compile option
        # You lose
        skip = False
        for match in invalid_unicode_re.finditer(data):
            if skip:
                continue
            codepoint = ord(match.group())
            pos = match.start()
            # Pretty sure there should be endianness issues here
            if _utils.is_surrogate_pair(data[pos:pos + 2]):
                # We have a surrogate pair!
                char_val = _utils.surrogate_pair_to_codepoint(data[pos:pos + 2])
                if char_val in non_bmp_invalid_codepoints:
                    self.errors.append("invalid-codepoint")
                skip = True
            elif (codepoint >= 0xD800 and codepoint <= 0xDFFF and
                  pos == len(data) - 1):
                self.errors.append("invalid-codepoint")
            else:
                skip = False
                self.errors.append("invalid-codepoint")

    def chars_until(self, characters, opposite=False):
        """ Returns a string of characters from the stream up to but not
        including any character in 'characters' or EOF. 'characters' must be
        a container that supports the 'in' method and iteration over its
        characters.
        """

        # Use a cache of regexps to find the required characters
        try:
            chars = chars_until_reg_ex[(characters, opposite)]
        except KeyError:
            if __debug__:
                for c in characters:
                    assert(ord(c) < 128)
            regex = "".join(["\\x%02x" % ord(c) for c in characters])
            if not opposite:
                regex = "^%s" % regex
            chars = chars_until_reg_ex[(characters, opposite)] = re.compile("[%s]+" % regex)

        rv = []

        while True:
            # Find the longest matching prefix
            m = chars.match(self.chunk, self.chunk_offset)
            if m is None:
                # If nothing matched, and it wasn't because we ran out of chunk,
                # then stop
                if self.chunk_offset != self.chunk_size:
                    break
            else:
                end = m.end()
                # If not the whole chunk matched, return everything
                # up to the part that didn't match
                if end != self.chunk_size:
                    rv.append(self.chunk[self.chunk_offset:end])
                    self.chunk_offset = end
                    break
            # If the whole remainder of the chunk matched,
            # use it all and read the next chunk
            rv.append(self.chunk[self.chunk_offset:])
            if not self.read_chunk():
                # Reached EOF
                break

        r = "".join(rv)
        return r

    def unget(self, char):
        # Only one character is allowed to be ungotten at once - it must
        # be consumed again before any further call to unget
        if char is not EOF:
            if self.chunk_offset == 0:
                # unget is called quite rarely, so it's a good idea to do
                # more work here if it saves a bit of work in the frequently
                # called char and chars_until.
                # So, just prepend the ungotten character onto the current
                # chunk:
                self.chunk = char + self.chunk
                self.chunk_size += 1
            else:
                self.chunk_offset -= 1
                assert self.chunk[self.chunk_offset] == char


class HTMLBinaryInputStream(HTMLUnicodeInputStream):
    """Provides a unicode stream of characters to the HTMLTokenizer.

    This class takes care of character encoding and removing or replacing
    incorrect byte-sequences and also provides column and line tracking.

    """

    def __init__(self, source, override_encoding=None, transport_encoding=None,
                 same_origin_parent_encoding=None, likely_encoding=None,
                 default_encoding="windows-1252", use_chardet=True):
        """Initialises the HTMLInputStream.

        HTMLInputStream(source, [encoding]) -> Normalized stream from source
        for use by html5lib.

        source can be either a file-object, local filename or a string.

        The optional encoding parameter must be a string that indicates
        the encoding.  If specified, that encoding will be used,
        regardless of any BOM or later declaration (such as in a meta
        element)

        """
        # Raw Stream - for unicode objects this will encode to utf-8 and set
        #              self.char_encoding as appropriate
        self.raw_stream = self.open_stream(source)

        HTMLUnicodeInputStream.__init__(self, self.raw_stream)

        # Encoding Information
        # Number of bytes to use when looking for a meta element with
        # encoding information
        self.num_bytes_meta = 1024
        # Number of bytes to use when using detecting encoding using chardet
        self.num_bytes_chardet = 100
        # Things from args
        self.override_encoding = override_encoding
        self.transport_encoding = transport_encoding
        self.same_origin_parent_encoding = same_origin_parent_encoding
        self.likely_encoding = likely_encoding
        self.default_encoding = default_encoding

        # Determine encoding
        self.char_encoding = self.determine_encoding(use_chardet)
        assert self.char_encoding[0] is not None

        # Call superclass
        self.reset()

    def reset(self):
        self.data_stream = self.char_encoding[0].codec_info.streamreader(self.raw_stream, 'replace')
        HTMLUnicodeInputStream.reset(self)

    def open_stream(self, source):
        """Produces a file object from source.

        source can be either a file object, local filename or a string.

        """
        # Already a file object
        if hasattr(source, 'read'):
            stream = source
        else:
            stream = BytesIO(source)

        try:
            stream.seek(stream.tell())
        except Exception:
            stream = BufferedStream(stream)

        return stream

    def determine_encoding(self, chardet=True):
        # BOMs take precedence over everything
        # This will also read past the BOM if present
        char_encoding = self.detect_bom(), "certain"
        if char_encoding[0] is not None:
            return char_encoding

        # If we've been overridden, we've been overridden
        char_encoding = lookup_encoding(self.override_encoding), "certain"
        if char_encoding[0] is not None:
            return char_encoding

        # Now check the transport layer
        char_encoding = lookup_encoding(self.transport_encoding), "certain"
        if char_encoding[0] is not None:
            return char_encoding

        # Look for meta elements with encoding information
        char_encoding = self.detect_encoding_meta(), "tentative"
        if char_encoding[0] is not None:
            return char_encoding

        # Parent document encoding
        char_encoding = lookup_encoding(self.same_origin_parent_encoding), "tentative"
        if char_encoding[0] is not None and not char_encoding[0].name.startswith("utf-16"):
            return char_encoding

        # "likely" encoding
        char_encoding = lookup_encoding(self.likely_encoding), "tentative"
        if char_encoding[0] is not None:
            return char_encoding

        # Guess with chardet, if available
        if chardet:
            try:
                from pip._vendor.chardet.universaldetector import UniversalDetector
            except ImportError:
                pass
            else:
                buffers = []
                detector = UniversalDetector()
                while not detector.done:
                    buffer = self.raw_stream.read(self.num_bytes_chardet)
                    assert isinstance(buffer, bytes)
                    if not buffer:
                        break
                    buffers.append(buffer)
                    detector.feed(buffer)
                detector.close()
                encoding = lookup_encoding(detector.result['encoding'])
                self.raw_stream.seek(0)
                if encoding is not None:
                    return encoding, "tentative"

        # Try the default encoding
        char_encoding = lookup_encoding(self.default_encoding), "tentative"
        if char_encoding[0] is not None:
            return char_encoding

        # Fallback to html5lib's default if even that hasn't worked
        return lookup_encoding("windows-1252"), "tentative"

    def change_encoding(self, new_encoding):
        assert self.char_encoding[1] != "certain"
        new_encoding = lookup_encoding(new_encoding)
        if new_encoding is None:
            return
        if new_encoding.name in ("utf-16be", "utf-16le"):
            new_encoding = lookup_encoding("utf-8")
            assert new_encoding is not None
        elif new_encoding == self.char_encoding[0]:
            self.char_encoding = (self.char_encoding[0], "certain")
        else:
            self.raw_stream.seek(0)
            self.char_encoding = (new_encoding, "certain")
            self.reset()
            raise _ReparseException("Encoding changed from %s to %s" % (self.char_encoding[0], new_encoding))

    def detect_bom(self):
        """Attempts to detect at BOM at the start of the stream. If
        an encoding can be determined from the BOM return the name of the
        encoding otherwise return None"""
        bom_dict = {
            codecs.BOM_UTF8: 'utf-8',
            codecs.BOM_UTF16_LE: 'utf-16le', codecs.BOM_UTF16_BE: 'utf-16be',
            codecs.BOM_UTF32_LE: 'utf-32le', codecs.BOM_UTF32_BE: 'utf-32be'
        }

        # Go to beginning of file and read in 4 bytes
        string = self.raw_stream.read(4)
        assert isinstance(string, bytes)

        # Try detecting the BOM using bytes from the string
        encoding = bom_dict.get(string[:3])         # UTF-8
        seek = 3
        if not encoding:
            # Need to detect UTF-32 before UTF-16
            encoding = bom_dict.get(string)         # UTF-32
            seek = 4
            if not encoding:
                encoding = bom_dict.get(string[:2])  # UTF-16
                seek = 2

        # Set the read position past the BOM if one was found, otherwise
        # set it to the start of the stream
        if encoding:
            self.raw_stream.seek(seek)
            return lookup_encoding(encoding)
        else:
            self.raw_stream.seek(0)
            return None

    def detect_encoding_meta(self):
        """Report the encoding declared by the meta element
        """
        buffer = self.raw_stream.read(self.num_bytes_meta)
        assert isinstance(buffer, bytes)
        parser = EncodingParser(buffer)
        self.raw_stream.seek(0)
        encoding = parser.get_encoding()

        if encoding is not None and encoding.name in ("utf-16be", "utf-16le"):
            encoding = lookup_encoding("utf-8")

        return encoding


class EncodingBytes(bytes):
    """String-like object with an associated position and various extra methods
    If the position is ever greater than the string length then an exception is
    raised"""
    def __new__(self, value):
        assert isinstance(value, bytes)
        return bytes.__new__(self, value.lower())

    def __init__(self, value):
        # pylint:disable=unused-argument
        self._position = -1

    def __iter__(self):
        return self

    def __next__(self):
        p = self._position = self._position + 1
        if p >= len(self):
            raise StopIteration
        elif p < 0:
            raise TypeError
        return self[p:p + 1]

    def next(self):
        # Py2 compat
        return self.__next__()

    def previous(self):
        p = self._position
        if p >= len(self):
            raise StopIteration
        elif p < 0:
            raise TypeError
        self._position = p = p - 1
        return self[p:p + 1]

    def set_position(self, position):
        if self._position >= len(self):
            raise StopIteration
        self._position = position

    def get_position(self):
        if self._position >= len(self):
            raise StopIteration
        if self._position >= 0:
            return self._position
        else:
            return None

    position = property(get_position, set_position)

    def get_current_byte(self):
        return self[self.position:self.position + 1]

    current_byte = property(get_current_byte)

    def skip(self, chars=space_characters_bytes):
        """Skip past a list of characters"""
        p = self.position               # use property for the error-checking
        while p < len(self):
            c = self[p:p + 1]
            if c not in chars:
                self._position = p
                return c
            p += 1
        self._position = p
        return None

    def skip_until(self, chars):
        p = self.position
        while p < len(self):
            c = self[p:p + 1]
            if c in chars:
                self._position = p
                return c
            p += 1
        self._position = p
        return None

    def match_bytes(self, bytes):
        """Look for a sequence of bytes at the start of a string. If the bytes
        are found return True and advance the position to the byte after the
        match. Otherwise return False and leave the position alone"""
        rv = self.startswith(bytes, self.position)
        if rv:
            self.position += len(bytes)
        return rv

    def jump_to(self, bytes):
        """Look for the next sequence of bytes matching a given sequence. If
        a match is found advance the position to the last byte of the match"""
        try:
            self._position = self.index(bytes, self.position) + len(bytes) - 1
        except ValueError:
            raise StopIteration
        return True


class EncodingParser(object):
    """Mini parser for detecting character encoding from meta elements"""

    def __init__(self, data):
        """string - the data to work on for encoding detection"""
        self.data = EncodingBytes(data)
        self.encoding = None

    def get_encoding(self):
        if b"<meta" not in self.data:
            return None

        method_dispatch = (
            (b"<!--", self.handle_comment),
            (b"<meta", self.handle_meta),
            (b"</", self.handle_possible_end_tag),
            (b"<!", self.handle_other),
            (b"<?", self.handle_other),
            (b"<", self.handle_possible_start_tag))
        for _ in self.data:
            keep_parsing = True
            try:
                self.data.jump_to(b"<")
            except StopIteration:
                break
            for key, method in method_dispatch:
                if self.data.match_bytes(key):
                    try:
                        keep_parsing = method()
                        break
                    except StopIteration:
                        keep_parsing = False
                        break
            if not keep_parsing:
                break

        return self.encoding

    def handle_comment(self):
        """Skip over comments"""
        return self.data.jump_to(b"-->")

    def handle_meta(self):
        if self.data.current_byte not in space_characters_bytes:
            # if we have <meta not followed by a space so just keep going
            return True
        # We have a valid meta element we want to search for attributes
        has_pragma = False
        pending_encoding = None
        while True:
            # Try to find the next attribute after the current position
            attr = self.get_attribute()
            if attr is None:
                return True
            else:
                if attr[0] == b"http-equiv":
                    has_pragma = attr[1] == b"content-type"
                    if has_pragma and pending_encoding is not None:
                        self.encoding = pending_encoding
                        return False
                elif attr[0] == b"charset":
                    tentative_encoding = attr[1]
                    codec = lookup_encoding(tentative_encoding)
                    if codec is not None:
                        self.encoding = codec
                        return False
                elif attr[0] == b"content":
                    content_parser = ContentAttrParser(EncodingBytes(attr[1]))
                    tentative_encoding = content_parser.parse()
                    if tentative_encoding is not None:
                        codec = lookup_encoding(tentative_encoding)
                        if codec is not None:
                            if has_pragma:
                                self.encoding = codec
                                return False
                            else:
                                pending_encoding = codec

    def handle_possible_start_tag(self):
        return self.handle_possible_tag(False)

    def handle_possible_end_tag(self):
        next(self.data)
        return self.handle_possible_tag(True)

    def handle_possible_tag(self, end_tag):
        data = self.data
        if data.current_byte not in ascii_letters_bytes:
            # If the next byte is not an ascii letter either ignore this
            # fragment (possible start tag case) or treat it according to
            # handle_other
            if end_tag:
                data.previous()
                self.handle_other()
            return True

        c = data.skip_until(spaces_angle_brackets)
        if c == b"<":
            # return to the first step in the overall "two step" algorithm
            # reprocessing the < byte
            data.previous()
        else:
            # Read all attributes
            attr = self.get_attribute()
            while attr is not None:
                attr = self.get_attribute()
        return True

    def handle_other(self):
        return self.data.jump_to(b">")

    def get_attribute(self):
        """Return a name,value pair for the next attribute in the stream,
        if one is found, or None"""
        data = self.data
        # Step 1 (skip chars)
        c = data.skip(space_characters_bytes | frozenset([b"/"]))
        assert c is None or len(c) == 1
        # Step 2
        if c in (b">", None):
            return None
        # Step 3
        attr_name = []
        attr_value = []
        # Step 4 attribute name
        while True:
            if c == b"=" and attr_name:
                break
            elif c in space_characters_bytes:
                # Step 6!
                c = data.skip()
                break
            elif c in (b"/", b">"):
                return b"".join(attr_name), b""
            elif c in ascii_uppercase_bytes:
                attr_name.append(c.lower())
            elif c is None:
                return None
            else:
                attr_name.append(c)
            # Step 5
            c = next(data)
        # Step 7
        if c != b"=":
            data.previous()
            return b"".join(attr_name), b""
        # Step 8
        next(data)
        # Step 9
        c = data.skip()
        # Step 10
        if c in (b"'", b'"'):
            # 10.1
            quote_char = c
            while True:
                # 10.2
                c = next(data)
                # 10.3
                if c == quote_char:
                    next(data)
                    return b"".join(attr_name), b"".join(attr_value)
                # 10.4
                elif c in ascii_uppercase_bytes:
                    attr_value.append(c.lower())
                # 10.5
                else:
                    attr_value.append(c)
        elif c == b">":
            return b"".join(attr_name), b""
        elif c in ascii_uppercase_bytes:
            attr_value.append(c.lower())
        elif c is None:
            return None
        else:
            attr_value.append(c)
        # Step 11
        while True:
            c = next(data)
            if c in spaces_angle_brackets:
                return b"".join(attr_name), b"".join(attr_value)
            elif c in ascii_uppercase_bytes:
                attr_value.append(c.lower())
            elif c is None:
                return None
            else:
                attr_value.append(c)


class ContentAttrParser(object):
    def __init__(self, data):
        assert isinstance(data, bytes)
        self.data = data

    def parse(self):
        try:
            # Check if the attr name is charset
            # otherwise return
            self.data.jump_to(b"charset")
            self.data.position += 1
            self.data.skip()
            if not self.data.current_byte == b"=":
                # If there is no = sign keep looking for attrs
                return None
            self.data.position += 1
            self.data.skip()
            # Look for an encoding between matching quote marks
            if self.data.current_byte in (b'"', b"'"):
                quote_mark = self.data.current_byte
                self.data.position += 1
                old_position = self.data.position
                if self.data.jump_to(quote_mark):
                    return self.data[old_position:self.data.position]
                else:
                    return None
            else:
                # Unquoted value
                old_position = self.data.position
                try:
                    self.data.skip_until(space_characters_bytes)
                    return self.data[old_position:self.data.position]
                except StopIteration:
                    # Return the whole remaining value
                    return self.data[old_position:]
        except StopIteration:
            return None


def lookup_encoding(encoding):
    """Return the python codec name corresponding to an encoding or None if the
    string doesn't correspond to a valid encoding."""
    if isinstance(encoding, bytes):
        try:
            encoding = encoding.decode("ascii")
        except UnicodeDecodeError:
            return None

    if encoding is not None:
        try:
            return webencodings.lookup(encoding)
        except AttributeError:
            return None
    else:
        return None
